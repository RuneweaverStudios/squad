#!/bin/bash
#
# squad-skills - Skill catalog, installer, and local management
#
# Usage:
#   squad-skills search <query>       # Search catalog by keyword
#   squad-skills list-available        # List all catalog skills
#   squad-skills info <skill-id>       # Show details of a specific skill
#   squad-skills install <name-or-url> # Install a skill locally
#   squad-skills list                  # List installed skills
#   squad-skills enable <name>         # Enable an installed skill
#   squad-skills disable <name>        # Disable an installed skill
#   squad-skills uninstall <name>      # Remove an installed skill
#   squad-skills update <name>         # Re-fetch skill from source
#   squad-skills sync                  # Sync agent links (Claude commands, Pi skills)
#   squad-skills refresh               # Force refresh the catalog cache
#   squad-skills sources               # Show configured sources and status
#   squad-skills --help                # Show this help
#
# Sources (priority order):
#   1. Curated list: ~/.config/squad/skill-catalog.json
#   2. GitHub search: repos with openclaw-skill / pi-skill topics
#   3. ClawHub CLI (if installed)
#
# Installed skills: ~/.config/squad/skills/{name}/SKILL.md
# Registry:         ~/.config/squad/skills/installed.json
# Cache:            ~/.config/squad/cache/skills-catalog.json (24h TTL)
#

set -euo pipefail

# Config
CATALOG_FILE="$HOME/.config/squad/skill-catalog.json"
CACHE_DIR="$HOME/.config/squad/cache"
CACHE_FILE="$CACHE_DIR/skills-catalog.json"
CACHE_TTL=86400  # 24 hours in seconds
SKILLS_DIR="$HOME/.config/squad/skills"
INSTALLED_FILE="$SKILLS_DIR/installed.json"
# Resolve through symlinks to find the real script location
REAL_SCRIPT="$(readlink -f "${BASH_SOURCE[0]}")"
DEFAULT_CATALOG="$(cd "$(dirname "$REAL_SCRIPT")/../scripts" && pwd)/skill-catalog-default.json"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

show_help() {
    cat << 'EOF'
squad-skills - Skill catalog, installer, and local management

CATALOG:
    squad-skills search <query>        Search catalog by keyword
    squad-skills list-available         List all catalog skills
    squad-skills info <skill-id>        Show skill details
    squad-skills refresh                Force refresh the catalog cache
    squad-skills sources                Show source status

INSTALL & MANAGE:
    squad-skills install <name-or-url>  Install a skill locally
    squad-skills list                   List installed skills
    squad-skills enable <name>          Enable an installed skill
    squad-skills disable <name>         Disable an installed skill
    squad-skills uninstall <name>       Remove an installed skill
    squad-skills update <name>          Re-fetch skill from source
    squad-skills sync                   Sync agent links (repair manually)

OPTIONS:
    squad-skills --json                 Output as JSON (combine with other commands)
    squad-skills --help                 Show this help

EXAMPLES:
    squad-skills search github          # Find GitHub-related skills
    squad-skills install git-commit     # Install from catalog by name
    squad-skills install https://github.com/user/repo  # Install from URL
    squad-skills list                   # Show installed + status
    squad-skills disable git-commit     # Disable without removing
    squad-skills update git-commit      # Re-fetch latest SKILL.md

INSTALL SOURCES:
    - Catalog name     Looks up skillMdUrl from catalog
    - GitHub repo URL  Fetches SKILL.md from repo root or subdirectory
    - Raw URL          Fetches SKILL.md directly

SKILL DIRECTORIES (searched by agents):
    1. Project-level   {project}/skills/
    2. User-level      ~/.config/squad/skills/
    3. SQUAD built-in    ~/code/squad/skills/

INSTALLED SKILLS:
    Skills stored in ~/.config/squad/skills/{name}/SKILL.md
    Registry at ~/.config/squad/skills/installed.json

AGENT LINKS (auto-synced on install/enable/disable/uninstall/update):
    Claude Code  ~/.claude/commands/{name}.md  → SKILL.md symlink
    Pi           ~/.pi/agent/skills/{id}/      → skill dir symlink
    Other agents receive skill info via prompt at spawn time
EOF
}

error() {
    echo -e "${RED}error:${NC} $1" >&2
    exit 1
}

warn() {
    echo -e "${YELLOW}warn:${NC} $1" >&2
}

info() {
    echo -e "${DIM}$1${NC}" >&2
}

# Ensure config dirs exist
ensure_dirs() {
    mkdir -p "$CACHE_DIR"
    mkdir -p "$(dirname "$CATALOG_FILE")"
    mkdir -p "$SKILLS_DIR"
}

# Initialize curated catalog if it doesn't exist
ensure_catalog() {
    if [[ ! -f "$CATALOG_FILE" ]]; then
        if [[ -f "$DEFAULT_CATALOG" ]]; then
            cp "$DEFAULT_CATALOG" "$CATALOG_FILE"
            info "Initialized curated catalog from defaults"
        else
            # Write minimal catalog
            echo '{"skills":[],"updatedAt":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' > "$CATALOG_FILE"
            warn "No default catalog found. Created empty catalog at $CATALOG_FILE"
        fi
    fi
}

# Check if cache is still valid
cache_valid() {
    if [[ ! -f "$CACHE_FILE" ]]; then
        return 1
    fi

    local now file_mtime age
    now=$(date +%s)

    # Cross-platform stat
    if [[ "$(uname)" == "Darwin" ]]; then
        file_mtime=$(stat -f %m "$CACHE_FILE")
    else
        file_mtime=$(stat -c %Y "$CACHE_FILE")
    fi

    age=$((now - file_mtime))
    [[ $age -lt $CACHE_TTL ]]
}

# Source 1: Read curated catalog
fetch_curated() {
    ensure_catalog
    if [[ -f "$CATALOG_FILE" ]]; then
        jq -r '.skills // []' "$CATALOG_FILE" 2>/dev/null || echo '[]'
    else
        echo '[]'
    fi
}

# Source 2: GitHub API search
fetch_github() {
    local github_token="${GITHUB_TOKEN:-}"
    local auth_header=""
    if [[ -n "$github_token" ]]; then
        auth_header="-H \"Authorization: token $github_token\""
    fi

    local results='[]'

    # Search for repos with openclaw-skill topic
    local openclaw_results
    openclaw_results=$(curl -sf \
        -H "Accept: application/vnd.github+json" \
        ${github_token:+-H "Authorization: token $github_token"} \
        "https://api.github.com/search/repositories?q=topic:openclaw-skill&sort=stars&order=desc&per_page=30" \
        2>/dev/null) || true

    if [[ -n "$openclaw_results" ]]; then
        local parsed
        parsed=$(echo "$openclaw_results" | jq '[.items // [] | .[] | {
            id: .name,
            name: (.name | gsub("-"; " ") | gsub("openclaw-skill-"; "") | gsub("skill-"; "")),
            description: (.description // "No description"),
            author: .owner.login,
            version: "latest",
            repoUrl: .html_url,
            skillMdUrl: (.html_url + "/blob/main/SKILL.md"),
            tags: [.topics[]? | select(. != "openclaw-skill")],
            installCount: .stargazers_count,
            compatible: true,
            source: "github-openclaw"
        }]' 2>/dev/null) || true

        if [[ -n "$parsed" && "$parsed" != "null" ]]; then
            results=$(echo "$results" "$parsed" | jq -s '.[0] + .[1]')
        fi
    fi

    # Search for repos with pi-skill topic
    local pi_results
    pi_results=$(curl -sf \
        -H "Accept: application/vnd.github+json" \
        ${github_token:+-H "Authorization: token $github_token"} \
        "https://api.github.com/search/repositories?q=topic:pi-skill&sort=stars&order=desc&per_page=20" \
        2>/dev/null) || true

    if [[ -n "$pi_results" ]]; then
        local parsed
        parsed=$(echo "$pi_results" | jq '[.items // [] | .[] | {
            id: .name,
            name: (.name | gsub("-"; " ") | gsub("pi-skill-"; "") | gsub("skill-"; "")),
            description: (.description // "No description"),
            author: .owner.login,
            version: "latest",
            repoUrl: .html_url,
            skillMdUrl: (.html_url + "/blob/main/SKILL.md"),
            tags: [.topics[]? | select(. != "pi-skill")],
            installCount: .stargazers_count,
            compatible: true,
            source: "github-pi"
        }]' 2>/dev/null) || true

        if [[ -n "$parsed" && "$parsed" != "null" ]]; then
            results=$(echo "$results" "$parsed" | jq -s '.[0] + .[1]')
        fi
    fi

    # Also search for agent-skill repos
    local agent_results
    agent_results=$(curl -sf \
        -H "Accept: application/vnd.github+json" \
        ${github_token:+-H "Authorization: token $github_token"} \
        "https://api.github.com/search/repositories?q=topic:agent-skill+SKILL.md+in:name&sort=stars&order=desc&per_page=20" \
        2>/dev/null) || true

    if [[ -n "$agent_results" ]]; then
        local parsed
        parsed=$(echo "$agent_results" | jq '[.items // [] | .[] | {
            id: .name,
            name: (.name | gsub("-"; " ") | gsub("agent-skill-"; "") | gsub("skill-"; "")),
            description: (.description // "No description"),
            author: .owner.login,
            version: "latest",
            repoUrl: .html_url,
            skillMdUrl: (.html_url + "/blob/main/SKILL.md"),
            tags: [.topics[]? | select(. != "agent-skill")],
            installCount: .stargazers_count,
            compatible: true,
            source: "github-agent"
        }]' 2>/dev/null) || true

        if [[ -n "$parsed" && "$parsed" != "null" ]]; then
            results=$(echo "$results" "$parsed" | jq -s '.[0] + .[1]')
        fi
    fi

    echo "$results"
}

# Source 3: ClawHub CLI
fetch_clawhub() {
    if ! command -v clawhub &>/dev/null; then
        echo '[]'
        return
    fi

    local raw_results
    raw_results=$(clawhub search "" --json --limit 50 2>/dev/null) || true

    if [[ -z "$raw_results" ]]; then
        echo '[]'
        return
    fi

    # Parse clawhub output into our format
    echo "$raw_results" | jq '[.[] | {
        id: (.slug // .name),
        name: .name,
        description: (.description // "No description"),
        author: (.author // .owner // "unknown"),
        version: (.version // "latest"),
        repoUrl: (.repoUrl // .repository // ""),
        skillMdUrl: ((.repoUrl // .repository // "") + "/blob/main/SKILL.md"),
        tags: (.tags // .categories // []),
        installCount: (.downloads // .installs // 0),
        compatible: true,
        source: "clawhub"
    }]' 2>/dev/null || echo '[]'
}

# Merge results from all sources, deduplicate by id
merge_results() {
    local curated="$1"
    local github="$2"
    local clawhub="$3"

    # Curated entries take priority, then clawhub, then github
    # Deduplicate by id (first occurrence wins)
    echo "$curated" "$clawhub" "$github" | jq -s '
        [.[0][], .[1][], .[2][]] |
        group_by(.id) |
        map(.[0]) |
        sort_by(-.installCount)
    ' 2>/dev/null || echo '[]'
}

# Build the full cache
build_cache() {
    info "Fetching from curated catalog..."
    local curated
    curated=$(fetch_curated)

    info "Fetching from GitHub API..."
    local github
    github=$(fetch_github)

    local clawhub='[]'
    if command -v clawhub &>/dev/null; then
        info "Fetching from ClawHub..."
        clawhub=$(fetch_clawhub)
    fi

    info "Merging results..."
    local merged
    merged=$(merge_results "$curated" "$github" "$clawhub")

    local count
    count=$(echo "$merged" | jq 'length')

    # Write cache
    jq -n \
        --argjson skills "$merged" \
        --arg updatedAt "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
        --arg curatedCount "$(echo "$curated" | jq 'length')" \
        --arg githubCount "$(echo "$github" | jq 'length')" \
        --arg clawhubCount "$(echo "$clawhub" | jq 'length')" \
        '{
            skills: $skills,
            updatedAt: $updatedAt,
            sources: {
                curated: ($curatedCount | tonumber),
                github: ($githubCount | tonumber),
                clawhub: ($clawhubCount | tonumber)
            },
            totalCount: ($skills | length)
        }' > "$CACHE_FILE"

    info "Cached $count skills from all sources"
}

# Get cached or fresh results
get_skills() {
    ensure_dirs

    if ! cache_valid; then
        build_cache
    fi

    jq -r '.skills' "$CACHE_FILE" 2>/dev/null || echo '[]'
}

# Check SKILL.md compatibility
check_compatibility() {
    local skill_md_url="$1"

    # Try to fetch SKILL.md and check for OpenClaw-specific tools
    local content
    content=$(curl -sf "$skill_md_url" 2>/dev/null) || return 0  # assume compatible if can't fetch

    # Check for OpenClaw-specific patterns
    if echo "$content" | grep -qi "openclaw\.\|requires:.*openclaw\|primaryEnv.*OPENCLAW"; then
        echo "false"
    else
        echo "true"
    fi
}

# --- Install management helpers ---

# Ensure installed.json exists and is valid
ensure_installed() {
    ensure_dirs
    if [[ ! -f "$INSTALLED_FILE" ]] || [[ ! -s "$INSTALLED_FILE" ]]; then
        echo '{"skills":{}}' > "$INSTALLED_FILE"
    fi
}

# Get installed skills JSON object
get_installed() {
    ensure_installed
    jq -r '.skills // {}' "$INSTALLED_FILE" 2>/dev/null || echo '{}'
}

# Save an entry to installed.json
save_installed_entry() {
    local skill_id="$1"
    local entry_json="$2"
    ensure_installed
    local tmp
    tmp=$(mktemp)
    jq --arg id "$skill_id" --argjson entry "$entry_json" \
        '.skills[$id] = $entry' "$INSTALLED_FILE" > "$tmp" && mv "$tmp" "$INSTALLED_FILE"
}

# Remove an entry from installed.json
remove_installed_entry() {
    local skill_id="$1"
    ensure_installed
    local tmp
    tmp=$(mktemp)
    jq --arg id "$skill_id" 'del(.skills[$id])' "$INSTALLED_FILE" > "$tmp" && mv "$tmp" "$INSTALLED_FILE"
}

# --- Agent link syncing ---

# Directories for agent-specific symlinks
CLAUDE_COMMANDS_DIR="$HOME/.claude/commands"
PI_SKILLS_DIR="$HOME/.pi/agent/skills"

# Sync symlinks into Claude Code commands dir and Pi skills dir
# based on which skills are currently enabled in installed.json
sync_agent_links() {
    ensure_installed
    local installed skill_id
    installed=$(get_installed)

    # Build set of enabled skill IDs and their invocation names
    local enabled_claude_links=()  # pairs: "name skill_id"
    local enabled_pi_links=()     # skill_ids

    local ids
    ids=$(echo "$installed" | jq -r 'keys[]' 2>/dev/null)
    for skill_id in $ids; do
        local enabled
        enabled=$(echo "$installed" | jq -r --arg id "$skill_id" 'if .[$id].enabled == false then "false" else "true" end')
        if [[ "$enabled" != "true" ]]; then
            continue
        fi

        # Get invocation name from frontmatter
        local skill_md="$SKILLS_DIR/$skill_id/SKILL.md"
        if [[ ! -f "$skill_md" ]]; then
            continue
        fi
        local invocation_name
        invocation_name=$(extract_frontmatter_field "$(cat "$skill_md")" "name")
        if [[ -z "$invocation_name" ]]; then
            invocation_name="$skill_id"
        fi

        enabled_claude_links+=("$invocation_name:$skill_id")
        enabled_pi_links+=("$skill_id")
    done

    # --- Claude Code: symlink SKILL.md as ~/.claude/commands/{name}.md ---
    if [[ -d "$CLAUDE_COMMANDS_DIR" ]] || mkdir -p "$CLAUDE_COMMANDS_DIR" 2>/dev/null; then
        # Create/verify links for enabled skills
        for pair in "${enabled_claude_links[@]}"; do
            local name="${pair%%:*}"
            local sid="${pair#*:}"
            local target="$CLAUDE_COMMANDS_DIR/${name}.md"
            local source="$SKILLS_DIR/$sid/SKILL.md"

            if [[ -L "$target" ]]; then
                # Already a symlink - check if it points into our skills dir
                local link_target
                link_target=$(readlink -f "$target" 2>/dev/null || true)
                if [[ "$link_target" == "$source" ]]; then
                    continue  # Already correct
                fi
                # Points somewhere else in our skills dir - update it
                if [[ "$link_target" == "$SKILLS_DIR"/* ]]; then
                    ln -sf "$source" "$target"
                fi
                # Points elsewhere entirely - skip (user's own command)
            elif [[ -e "$target" ]]; then
                # Regular file/dir exists - don't overwrite user's own command
                continue
            else
                ln -s "$source" "$target"
            fi
        done

        # Orphan cleanup: remove symlinks that point into squad-skills but aren't enabled
        local enabled_names=()
        for pair in "${enabled_claude_links[@]}"; do
            enabled_names+=("${pair%%:*}")
        done

        for link in "$CLAUDE_COMMANDS_DIR"/*.md; do
            [[ -e "$link" || -L "$link" ]] || continue
            [[ -L "$link" ]] || continue

            local link_target
            link_target=$(readlink -f "$link" 2>/dev/null || true)
            # Only remove if it points into our skills dir
            [[ "$link_target" == "$SKILLS_DIR"/* ]] || continue

            local link_name
            link_name=$(basename "$link" .md)
            local is_enabled=false
            for en in "${enabled_names[@]}"; do
                if [[ "$en" == "$link_name" ]]; then
                    is_enabled=true
                    break
                fi
            done
            if [[ "$is_enabled" == "false" ]]; then
                rm -f "$link"
            fi
        done
    fi

    # --- Pi: symlink skill directory as ~/.pi/agent/skills/{id}/ ---
    if [[ -d "$PI_SKILLS_DIR" ]] || mkdir -p "$PI_SKILLS_DIR" 2>/dev/null; then
        # Create/verify links for enabled skills
        for sid in "${enabled_pi_links[@]}"; do
            local target="$PI_SKILLS_DIR/$sid"
            local source="$SKILLS_DIR/$sid"

            if [[ -L "$target" ]]; then
                local link_target
                link_target=$(readlink -f "$target" 2>/dev/null || true)
                if [[ "$link_target" == "$source" ]]; then
                    continue  # Already correct
                fi
                if [[ "$link_target" == "$SKILLS_DIR"/* ]]; then
                    ln -sfn "$source" "$target"
                fi
            elif [[ -e "$target" ]]; then
                continue  # Don't overwrite user's own skill
            else
                ln -s "$source" "$target"
            fi
        done

        # Orphan cleanup: remove symlinks that point into squad-skills but aren't enabled
        for link in "$PI_SKILLS_DIR"/*/; do
            [[ -L "${link%/}" ]] || continue
            local link_target
            link_target=$(readlink -f "${link%/}" 2>/dev/null || true)
            [[ "$link_target" == "$SKILLS_DIR"/* ]] || continue

            local link_name
            link_name=$(basename "${link%/}")
            local is_enabled=false
            for en in "${enabled_pi_links[@]}"; do
                if [[ "$en" == "$link_name" ]]; then
                    is_enabled=true
                    break
                fi
            done
            if [[ "$is_enabled" == "false" ]]; then
                rm -f "${link%/}"
            fi
        done
    fi
}

# Validate SKILL.md content - checks for frontmatter with name and description
validate_skill_md() {
    local content="$1"

    # Must start with ---
    if ! echo "$content" | head -1 | grep -q '^---'; then
        echo "Missing YAML frontmatter (must start with ---)"
        return 1
    fi

    # Must have closing ---
    if ! echo "$content" | tail -n +2 | grep -q '^---'; then
        echo "Missing closing frontmatter delimiter (---)"
        return 1
    fi

    # Extract frontmatter (between first and second ---)
    local frontmatter
    frontmatter=$(echo "$content" | sed -n '2,/^---$/p' | head -n -1)

    # Must have name field
    if ! echo "$frontmatter" | grep -q '^name:'; then
        echo "Missing required 'name' field in frontmatter"
        return 1
    fi

    # Must have description field
    if ! echo "$frontmatter" | grep -q '^description:'; then
        echo "Missing required 'description' field in frontmatter"
        return 1
    fi

    # Must have content after frontmatter
    local body
    body=$(echo "$content" | awk 'BEGIN{c=0} /^---$/{c++;next} c>=2{print}')
    if [[ -z "$(echo "$body" | tr -d '[:space:]')" ]]; then
        echo "No content after frontmatter"
        return 1
    fi

    return 0
}

# Extract a frontmatter field value from SKILL.md content
extract_frontmatter_field() {
    local content="$1"
    local field="$2"
    echo "$content" | sed -n '2,/^---$/p' | head -n -1 | grep "^${field}:" | sed "s/^${field}:[[:space:]]*//" | sed 's/^["'"'"']\(.*\)["'"'"']$/\1/'
}

# Convert a GitHub blob URL to raw URL
github_to_raw_url() {
    local url="$1"
    # https://github.com/user/repo/blob/main/path/SKILL.md
    # → https://raw.githubusercontent.com/user/repo/main/path/SKILL.md
    echo "$url" | sed 's|github\.com/\([^/]*/[^/]*\)/blob/|raw.githubusercontent.com/\1/|'
}

# Resolve a skill name or URL to a fetchable SKILL.md URL and skill ID
# Sets: RESOLVED_URL, RESOLVED_ID, RESOLVED_SOURCE
resolve_skill_source() {
    local input="$1"
    RESOLVED_URL=""
    RESOLVED_ID=""
    RESOLVED_SOURCE=""

    if [[ "$input" =~ ^https?:// ]]; then
        # It's a URL
        if [[ "$input" =~ github\.com/([^/]+)/([^/]+)/?$ ]]; then
            # Bare GitHub repo URL → try SKILL.md in root
            local user="${BASH_REMATCH[1]}"
            local repo="${BASH_REMATCH[2]}"
            repo="${repo%.git}"
            RESOLVED_URL="https://raw.githubusercontent.com/${user}/${repo}/main/SKILL.md"
            RESOLVED_ID="$repo"
            RESOLVED_SOURCE="$input"
        elif [[ "$input" =~ github\.com/.*/blob/ ]]; then
            # GitHub blob URL → convert to raw
            RESOLVED_URL=$(github_to_raw_url "$input")
            # Extract skill name from path (last dir before SKILL.md, or repo name)
            local path_part
            path_part=$(echo "$input" | sed 's|.*/blob/[^/]*/||' | sed 's|/SKILL\.md$||')
            if [[ -n "$path_part" && "$path_part" != "SKILL.md" ]]; then
                RESOLVED_ID=$(basename "$path_part")
            else
                RESOLVED_ID=$(echo "$input" | sed 's|.*/\([^/]*/[^/]*\)/blob/.*|\1|' | sed 's|.*/||')
            fi
            RESOLVED_SOURCE="$input"
        elif [[ "$input" =~ raw\.githubusercontent\.com/ ]]; then
            # Already a raw URL
            RESOLVED_URL="$input"
            local path_part
            path_part=$(echo "$input" | sed 's|.*/main/||; s|/SKILL\.md$||')
            if [[ -n "$path_part" && "$path_part" != "SKILL.md" ]]; then
                RESOLVED_ID=$(basename "$path_part")
            else
                RESOLVED_ID=$(echo "$input" | sed 's|.*/\([^/]*/[^/]*\)/main/.*|\1|' | sed 's|.*/||')
            fi
            RESOLVED_SOURCE="$input"
        else
            # Generic URL - assume it points to SKILL.md directly
            RESOLVED_URL="$input"
            RESOLVED_ID=$(basename "$(dirname "$input")" 2>/dev/null || echo "unknown-skill")
            if [[ "$RESOLVED_ID" == "." || "$RESOLVED_ID" == "/" ]]; then
                RESOLVED_ID="unknown-skill"
            fi
            RESOLVED_SOURCE="$input"
        fi
    else
        # It's a catalog name - look up in catalog
        local skills
        skills=$(get_skills)

        local skill
        skill=$(echo "$skills" | jq --arg id "$input" '[.[] | select(.id == $id)] | .[0] // empty')

        if [[ -z "$skill" || "$skill" == "null" ]]; then
            # Try fuzzy match
            skill=$(echo "$skills" | jq --arg id "$input" '[
                .[] | select(.id | ascii_downcase | contains($id | ascii_downcase))
            ] | .[0] // empty')
        fi

        if [[ -z "$skill" || "$skill" == "null" ]]; then
            error "Skill '$input' not found in catalog.\nUse 'squad-skills search $input' to find similar skills,\nor provide a direct URL to install."
        fi

        local skill_md_url
        skill_md_url=$(echo "$skill" | jq -r '.skillMdUrl // empty')
        if [[ -z "$skill_md_url" ]]; then
            error "No SKILL.md URL found for '$input' in catalog"
        fi

        # Convert GitHub blob URLs to raw
        if [[ "$skill_md_url" =~ github\.com/.*/blob/ ]]; then
            RESOLVED_URL=$(github_to_raw_url "$skill_md_url")
        else
            RESOLVED_URL="$skill_md_url"
        fi
        RESOLVED_ID=$(echo "$skill" | jq -r '.id')
        RESOLVED_SOURCE="catalog:${RESOLVED_ID}"
    fi
}

# Format a single skill for display
format_skill() {
    local skill="$1"
    local id name desc author version tags compat source stars

    id=$(echo "$skill" | jq -r '.id')
    name=$(echo "$skill" | jq -r '.name')
    desc=$(echo "$skill" | jq -r '.description // "No description"')
    author=$(echo "$skill" | jq -r '.author // "unknown"')
    version=$(echo "$skill" | jq -r '.version // "latest"')
    tags=$(echo "$skill" | jq -r '.tags // [] | join(", ")')
    compat=$(echo "$skill" | jq -r '.compatible')
    source=$(echo "$skill" | jq -r '.source // "curated"')
    stars=$(echo "$skill" | jq -r '.installCount // 0')

    local compat_badge
    if [[ "$compat" == "true" ]]; then
        compat_badge="${GREEN}compatible${NC}"
    else
        compat_badge="${YELLOW}check required${NC}"
    fi

    echo -e "  ${BOLD}${CYAN}$id${NC} ${DIM}v$version${NC} ${DIM}by${NC} $author"
    echo -e "    $desc"
    if [[ -n "$tags" ]]; then
        echo -e "    ${DIM}tags:${NC} $tags"
    fi
    echo -e "    ${DIM}source:${NC} $source  ${DIM}stars:${NC} $stars  $compat_badge"
    echo ""
}

# --- Commands ---

cmd_search() {
    local query="${1:-}"
    if [[ -z "$query" ]]; then
        error "Usage: squad-skills search <query>"
    fi

    local skills
    skills=$(get_skills)

    local query_lower
    query_lower=$(echo "$query" | tr '[:upper:]' '[:lower:]')

    local results
    results=$(echo "$skills" | jq --arg q "$query_lower" '[
        .[] | select(
            (.id | ascii_downcase | contains($q)) or
            (.name | ascii_downcase | contains($q)) or
            (.description | ascii_downcase | contains($q)) or
            (.tags // [] | map(ascii_downcase) | any(contains($q))) or
            (.author | ascii_downcase | contains($q))
        )
    ]')

    local count
    count=$(echo "$results" | jq 'length')

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$results"
        return
    fi

    if [[ "$count" -eq 0 ]]; then
        echo -e "No skills found matching ${BOLD}$query${NC}"
        echo -e "${DIM}Try a broader search term or run 'squad-skills refresh'${NC}"
        return
    fi

    echo -e "${BOLD}Found $count skill(s) matching \"$query\":${NC}"
    echo ""

    echo "$results" | jq -c '.[]' | while IFS= read -r skill; do
        format_skill "$skill"
    done
}

cmd_list() {
    local skills
    skills=$(get_skills)

    local count
    count=$(echo "$skills" | jq 'length')

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$skills"
        return
    fi

    echo -e "${BOLD}Available skills ($count):${NC}"
    echo ""

    echo "$skills" | jq -c '.[]' | while IFS= read -r skill; do
        format_skill "$skill"
    done

    # Show cache info
    if [[ -f "$CACHE_FILE" ]]; then
        local updated sources
        updated=$(jq -r '.updatedAt' "$CACHE_FILE")
        sources=$(jq -r '.sources | to_entries | map("\(.key): \(.value)") | join(", ")' "$CACHE_FILE")
        echo -e "${DIM}Last updated: $updated${NC}"
        echo -e "${DIM}Sources: $sources${NC}"
    fi
}

cmd_info() {
    local skill_id="${1:-}"
    if [[ -z "$skill_id" ]]; then
        error "Usage: squad-skills info <skill-id>"
    fi

    local skills
    skills=$(get_skills)

    local skill
    skill=$(echo "$skills" | jq --arg id "$skill_id" '[.[] | select(.id == $id)] | .[0] // empty')

    if [[ -z "$skill" || "$skill" == "null" ]]; then
        # Try fuzzy match
        skill=$(echo "$skills" | jq --arg id "$skill_id" '[
            .[] | select(.id | ascii_downcase | contains($id | ascii_downcase))
        ] | .[0] // empty')
    fi

    if [[ -z "$skill" || "$skill" == "null" ]]; then
        error "Skill not found: $skill_id\nUse 'squad-skills search $skill_id' to find similar skills"
    fi

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$skill"
        return
    fi

    local id name desc author version tags compat source stars repo skill_md
    id=$(echo "$skill" | jq -r '.id')
    name=$(echo "$skill" | jq -r '.name')
    desc=$(echo "$skill" | jq -r '.description // "No description"')
    author=$(echo "$skill" | jq -r '.author // "unknown"')
    version=$(echo "$skill" | jq -r '.version // "latest"')
    tags=$(echo "$skill" | jq -r '.tags // [] | join(", ")')
    compat=$(echo "$skill" | jq -r '.compatible')
    source=$(echo "$skill" | jq -r '.source // "curated"')
    stars=$(echo "$skill" | jq -r '.installCount // 0')
    repo=$(echo "$skill" | jq -r '.repoUrl // "N/A"')
    skill_md=$(echo "$skill" | jq -r '.skillMdUrl // "N/A"')

    local compat_text
    if [[ "$compat" == "true" ]]; then
        compat_text="${GREEN}Yes - compatible with SQUAD${NC}"
    else
        compat_text="${YELLOW}Check required - may use OpenClaw-specific features${NC}"
    fi

    echo -e "${BOLD}${CYAN}$id${NC}"
    echo -e "  ${BOLD}Name:${NC}         $name"
    echo -e "  ${BOLD}Description:${NC}  $desc"
    echo -e "  ${BOLD}Author:${NC}       $author"
    echo -e "  ${BOLD}Version:${NC}      $version"
    echo -e "  ${BOLD}Source:${NC}       $source"
    echo -e "  ${BOLD}Stars:${NC}        $stars"
    echo -e "  ${BOLD}Tags:${NC}         ${tags:-none}"
    echo -e "  ${BOLD}Compatible:${NC}   $compat_text"
    echo -e "  ${BOLD}Repository:${NC}   $repo"
    echo -e "  ${BOLD}SKILL.md:${NC}     $skill_md"
}

cmd_refresh() {
    ensure_dirs
    info "Forcing cache refresh..."
    rm -f "$CACHE_FILE"
    build_cache
    local count
    count=$(jq -r '.totalCount' "$CACHE_FILE")
    echo -e "${GREEN}Cache refreshed:${NC} $count skills from all sources"
}

cmd_sources() {
    echo -e "${BOLD}Skill Catalog Sources:${NC}"
    echo ""

    # Source 1: Curated
    if [[ -f "$CATALOG_FILE" ]]; then
        local curated_count
        curated_count=$(jq '.skills | length' "$CATALOG_FILE" 2>/dev/null || echo "0")
        echo -e "  ${GREEN}1.${NC} ${BOLD}Curated Catalog${NC} - $curated_count skills"
        echo -e "     ${DIM}$CATALOG_FILE${NC}"
    else
        echo -e "  ${YELLOW}1.${NC} ${BOLD}Curated Catalog${NC} - not initialized"
        echo -e "     ${DIM}Run any command to initialize from defaults${NC}"
    fi

    echo ""

    # Source 2: GitHub
    local gh_status="${GREEN}available${NC}"
    if [[ -z "${GITHUB_TOKEN:-}" ]]; then
        gh_status="${YELLOW}no token (rate-limited to 10 req/min)${NC}"
    fi
    echo -e "  ${GREEN}2.${NC} ${BOLD}GitHub API${NC} - $gh_status"
    echo -e "     ${DIM}Topics: openclaw-skill, pi-skill, agent-skill${NC}"

    echo ""

    # Source 3: ClawHub
    if command -v clawhub &>/dev/null; then
        echo -e "  ${GREEN}3.${NC} ${BOLD}ClawHub CLI${NC} - installed"
        echo -e "     ${DIM}$(clawhub --version 2>/dev/null || echo "version unknown")${NC}"
    else
        echo -e "  ${DIM}3.${NC} ${BOLD}ClawHub CLI${NC} - ${DIM}not installed (optional)${NC}"
        echo -e "     ${DIM}Install: npm install -g clawhub${NC}"
    fi

    echo ""

    # Cache status
    if [[ -f "$CACHE_FILE" ]]; then
        local updated total
        updated=$(jq -r '.updatedAt' "$CACHE_FILE")
        total=$(jq -r '.totalCount' "$CACHE_FILE")
        echo -e "  ${BOLD}Cache:${NC} $total skills, last updated $updated"
        echo -e "  ${DIM}$CACHE_FILE${NC}"
    else
        echo -e "  ${BOLD}Cache:${NC} empty"
    fi
}

# --- Install & Management Commands ---

cmd_install() {
    local input="${1:-}"
    if [[ -z "$input" ]]; then
        error "Usage: squad-skills install <name-or-url>\n\nExamples:\n  squad-skills install git-commit\n  squad-skills install https://github.com/user/repo"
    fi

    ensure_dirs

    # For non-URL inputs, check if already installed before catalog lookup
    if [[ ! "$input" =~ ^https?:// ]]; then
        local existing
        existing=$(get_installed | jq --arg id "$input" '.[$id] // empty')
        if [[ -n "$existing" && "$existing" != "null" ]]; then
            warn "Skill '$input' is already installed. Use 'squad-skills update $input' to re-fetch."
            return 1
        fi
    fi

    # Resolve source
    resolve_skill_source "$input"

    if [[ -z "$RESOLVED_URL" || -z "$RESOLVED_ID" ]]; then
        error "Could not resolve skill source for '$input'"
    fi

    # Check if already installed (for URL-based installs, check after resolving ID)
    if [[ "$input" =~ ^https?:// ]]; then
        local existing
        existing=$(get_installed | jq --arg id "$RESOLVED_ID" '.[$id] // empty')
        if [[ -n "$existing" && "$existing" != "null" ]]; then
            warn "Skill '$RESOLVED_ID' is already installed. Use 'squad-skills update $RESOLVED_ID' to re-fetch."
            return 1
        fi
    fi

    info "Fetching SKILL.md from $RESOLVED_URL ..."

    local content
    content=$(curl -sf --max-time 15 "$RESOLVED_URL" 2>/dev/null) || true

    if [[ -z "$content" ]]; then
        # If bare repo URL, try HEAD branch too
        if [[ "$RESOLVED_URL" =~ raw\.githubusercontent\.com/([^/]+)/([^/]+)/main/SKILL\.md$ ]]; then
            local user="${BASH_REMATCH[1]}"
            local repo="${BASH_REMATCH[2]}"
            local alt_url="https://raw.githubusercontent.com/${user}/${repo}/master/SKILL.md"
            info "Trying master branch..."
            content=$(curl -sf --max-time 15 "$alt_url" 2>/dev/null) || true
            if [[ -n "$content" ]]; then
                RESOLVED_URL="$alt_url"
            fi
        fi
    fi

    if [[ -z "$content" ]]; then
        error "Failed to fetch SKILL.md from: $RESOLVED_URL"
    fi

    # Validate
    local validation_error
    validation_error=$(validate_skill_md "$content" 2>&1) || {
        error "Invalid SKILL.md: $validation_error"
    }

    # Extract metadata from frontmatter
    local skill_name skill_desc skill_version skill_author
    skill_name=$(extract_frontmatter_field "$content" "name")
    skill_desc=$(extract_frontmatter_field "$content" "description")
    # Try to get version from metadata block (indented under metadata:)
    skill_version=$(echo "$content" | sed -n '2,/^---$/p' | head -n -1 | grep '  version:' | sed 's/.*version:[[:space:]]*//' | sed 's/^["'"'"']\(.*\)["'"'"']$/\1/' || true)
    if [[ -z "$skill_version" ]]; then
        skill_version="latest"
    fi
    skill_author=$(echo "$content" | sed -n '2,/^---$/p' | head -n -1 | grep '  author:' | sed 's/.*author:[[:space:]]*//' | sed 's/^["'"'"']\(.*\)["'"'"']$/\1/' || true)
    if [[ -z "$skill_author" ]]; then
        skill_author="unknown"
    fi

    # Create skill directory and write SKILL.md
    local skill_dir="$SKILLS_DIR/$RESOLVED_ID"
    mkdir -p "$skill_dir"
    echo "$content" > "$skill_dir/SKILL.md"

    # Record in installed.json
    local now
    now=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    local entry
    entry=$(jq -n \
        --arg name "$skill_name" \
        --arg description "$skill_desc" \
        --arg version "$skill_version" \
        --arg author "$skill_author" \
        --arg source "$RESOLVED_SOURCE" \
        --arg sourceUrl "$RESOLVED_URL" \
        --arg installedAt "$now" \
        --arg updatedAt "$now" \
        '{
            name: $name,
            description: $description,
            version: $version,
            author: $author,
            source: $source,
            sourceUrl: $sourceUrl,
            installedAt: $installedAt,
            updatedAt: $updatedAt,
            enabled: true
        }')

    save_installed_entry "$RESOLVED_ID" "$entry"
    sync_agent_links

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        jq -n --arg id "$RESOLVED_ID" --argjson entry "$entry" '{id: $id} + $entry'
        return
    fi

    echo -e "${GREEN}Installed:${NC} ${BOLD}${CYAN}$RESOLVED_ID${NC}"
    echo -e "  ${DIM}Name:${NC}    $skill_name"
    echo -e "  ${DIM}Version:${NC} $skill_version"
    echo -e "  ${DIM}Author:${NC}  $skill_author"
    echo -e "  ${DIM}Source:${NC}  $RESOLVED_SOURCE"
    echo -e "  ${DIM}Path:${NC}    $skill_dir/SKILL.md"
}

cmd_list_installed() {
    ensure_installed
    local installed
    installed=$(get_installed)

    local count
    count=$(echo "$installed" | jq 'length')

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$installed" | jq '[to_entries[] | {id: .key} + .value]'
        return
    fi

    if [[ "$count" -eq 0 ]]; then
        echo -e "No skills installed."
        echo -e "${DIM}Use 'squad-skills install <name>' to install from catalog${NC}"
        echo -e "${DIM}Use 'squad-skills list-available' to browse the catalog${NC}"
        return
    fi

    echo -e "${BOLD}Installed skills ($count):${NC}"
    echo ""

    echo "$installed" | jq -c 'to_entries[]' | while IFS= read -r entry; do
        local id name version author enabled source
        id=$(echo "$entry" | jq -r '.key')
        name=$(echo "$entry" | jq -r '.value.name // .key')
        version=$(echo "$entry" | jq -r '.value.version // "latest"')
        author=$(echo "$entry" | jq -r '.value.author // "unknown"')
        enabled=$(echo "$entry" | jq -r 'if .value.enabled == false then "false" else "true" end')
        source=$(echo "$entry" | jq -r '.value.source // "unknown"')

        local status_badge
        if [[ "$enabled" == "false" ]]; then
            status_badge="${YELLOW}disabled${NC}"
        else
            status_badge="${GREEN}enabled${NC}"
        fi

        echo -e "  ${BOLD}${CYAN}$id${NC} ${DIM}v$version${NC} ${DIM}by${NC} $author  $status_badge"
        echo -e "    ${DIM}$name${NC}"
        echo -e "    ${DIM}source:${NC} $source"
        echo ""
    done
}

cmd_enable() {
    local skill_id="${1:-}"
    if [[ -z "$skill_id" ]]; then
        error "Usage: squad-skills enable <name>"
    fi

    ensure_installed
    local existing
    existing=$(get_installed | jq --arg id "$skill_id" '.[$id] // empty')

    if [[ -z "$existing" || "$existing" == "null" ]]; then
        error "Skill '$skill_id' is not installed.\nUse 'squad-skills list' to see installed skills."
    fi

    local already_enabled
    already_enabled=$(echo "$existing" | jq -r 'if .enabled == false then "false" else "true" end')
    if [[ "$already_enabled" == "true" ]]; then
        echo -e "Skill ${BOLD}$skill_id${NC} is already enabled."
        return
    fi

    local updated
    updated=$(echo "$existing" | jq --arg now "$(date -u +%Y-%m-%dT%H:%M:%SZ)" '.enabled = true | .updatedAt = $now')
    save_installed_entry "$skill_id" "$updated"
    sync_agent_links

    echo -e "${GREEN}Enabled:${NC} ${BOLD}$skill_id${NC}"
}

cmd_disable() {
    local skill_id="${1:-}"
    if [[ -z "$skill_id" ]]; then
        error "Usage: squad-skills disable <name>"
    fi

    ensure_installed
    local existing
    existing=$(get_installed | jq --arg id "$skill_id" '.[$id] // empty')

    if [[ -z "$existing" || "$existing" == "null" ]]; then
        error "Skill '$skill_id' is not installed.\nUse 'squad-skills list' to see installed skills."
    fi

    local already_disabled
    already_disabled=$(echo "$existing" | jq -r 'if .enabled == false then "false" else "true" end')
    if [[ "$already_disabled" == "false" ]]; then
        echo -e "Skill ${BOLD}$skill_id${NC} is already disabled."
        return
    fi

    local updated
    updated=$(echo "$existing" | jq --arg now "$(date -u +%Y-%m-%dT%H:%M:%SZ)" '.enabled = false | .updatedAt = $now')
    save_installed_entry "$skill_id" "$updated"
    sync_agent_links

    echo -e "${YELLOW}Disabled:${NC} ${BOLD}$skill_id${NC}"
}

cmd_uninstall() {
    local skill_id="${1:-}"
    if [[ -z "$skill_id" ]]; then
        error "Usage: squad-skills uninstall <name>"
    fi

    ensure_installed
    local existing
    existing=$(get_installed | jq --arg id "$skill_id" '.[$id] // empty')

    if [[ -z "$existing" || "$existing" == "null" ]]; then
        error "Skill '$skill_id' is not installed.\nUse 'squad-skills list' to see installed skills."
    fi

    # Remove skill directory
    local skill_dir="$SKILLS_DIR/$skill_id"
    if [[ -d "$skill_dir" ]]; then
        rm -rf "$skill_dir"
    fi

    # Remove from registry
    remove_installed_entry "$skill_id"
    sync_agent_links

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        jq -n --arg id "$skill_id" '{"id": $id, "uninstalled": true}'
        return
    fi

    echo -e "${GREEN}Uninstalled:${NC} ${BOLD}$skill_id${NC}"
}

cmd_update_skill() {
    local skill_id="${1:-}"
    if [[ -z "$skill_id" ]]; then
        error "Usage: squad-skills update <name>\n\nTo refresh the catalog cache, use 'squad-skills refresh'"
    fi

    ensure_installed
    local existing
    existing=$(get_installed | jq --arg id "$skill_id" '.[$id] // empty')

    if [[ -z "$existing" || "$existing" == "null" ]]; then
        error "Skill '$skill_id' is not installed.\nUse 'squad-skills list' to see installed skills."
    fi

    local source_url
    source_url=$(echo "$existing" | jq -r '.sourceUrl // empty')

    if [[ -z "$source_url" ]]; then
        # Try to resolve from catalog
        local source
        source=$(echo "$existing" | jq -r '.source // empty')
        if [[ "$source" =~ ^catalog: ]]; then
            resolve_skill_source "$skill_id"
            source_url="$RESOLVED_URL"
        fi
    fi

    if [[ -z "$source_url" ]]; then
        error "No source URL recorded for '$skill_id'. Cannot update.\nUninstall and reinstall with a URL."
    fi

    info "Fetching SKILL.md from $source_url ..."

    local content
    content=$(curl -sf --max-time 15 "$source_url" 2>/dev/null) || true

    if [[ -z "$content" ]]; then
        error "Failed to fetch SKILL.md from: $source_url"
    fi

    # Validate
    local validation_error
    validation_error=$(validate_skill_md "$content" 2>&1) || {
        error "Invalid SKILL.md: $validation_error"
    }

    # Write updated SKILL.md
    local skill_dir="$SKILLS_DIR/$skill_id"
    mkdir -p "$skill_dir"
    echo "$content" > "$skill_dir/SKILL.md"

    # Update metadata
    local skill_version
    skill_version=$(echo "$content" | sed -n '2,/^---$/p' | head -n -1 | grep '  version:' | sed 's/.*version:[[:space:]]*//' | sed 's/^["'"'"']\(.*\)["'"'"']$/\1/' || true)
    if [[ -z "$skill_version" ]]; then
        skill_version="latest"
    fi

    local now
    now=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    local updated
    updated=$(echo "$existing" | jq --arg now "$now" --arg ver "$skill_version" '.updatedAt = $now | .version = $ver')
    save_installed_entry "$skill_id" "$updated"
    sync_agent_links

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        jq -n --arg id "$skill_id" --arg version "$skill_version" --arg updatedAt "$now" \
            '{id: $id, version: $version, updatedAt: $updatedAt, updated: true}'
        return
    fi

    echo -e "${GREEN}Updated:${NC} ${BOLD}${CYAN}$skill_id${NC} ${DIM}v$skill_version${NC}"
}

# --- Main ---

JSON_OUTPUT="false"

# Parse global flags
args=()
for arg in "$@"; do
    case "$arg" in
        --json) JSON_OUTPUT="true" ;;
        *) args+=("$arg") ;;
    esac
done

set -- "${args[@]+"${args[@]}"}"

case "${1:-}" in
    search)
        shift
        cmd_search "${1:-}"
        ;;
    list-available)
        cmd_list
        ;;
    list|ls)
        cmd_list_installed
        ;;
    info|show)
        shift
        cmd_info "${1:-}"
        ;;
    install)
        shift
        cmd_install "${1:-}"
        ;;
    enable)
        shift
        cmd_enable "${1:-}"
        ;;
    disable)
        shift
        cmd_disable "${1:-}"
        ;;
    uninstall|remove)
        shift
        cmd_uninstall "${1:-}"
        ;;
    update)
        shift
        if [[ -n "${1:-}" ]]; then
            cmd_update_skill "$1"
        else
            # Bare 'update' with no arg → refresh cache (backward compat)
            cmd_refresh
        fi
        ;;
    sync)
        sync_agent_links
        echo -e "${GREEN}Agent links synced.${NC}"
        ;;
    refresh)
        cmd_refresh
        ;;
    sources|status)
        cmd_sources
        ;;
    --help|-h|help)
        show_help
        ;;
    --version|-v)
        echo "squad-skills 2.0.0"
        ;;
    "")
        show_help
        ;;
    -*)
        error "Unknown option: $1\nUse --help for usage"
        ;;
    *)
        # If not a command, treat as a search query
        cmd_search "$1"
        ;;
esac
