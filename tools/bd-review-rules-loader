#!/bin/bash

# bd-review-rules-loader - Load and manage review-rules.json for Beads
#
# This script provides a structured JSON file for review rules with schema
# validation, migration support, and syncing with bd config.
#
# Schema location: .beads/review-rules.json
#
# Usage:
#   bd-review-rules-loader                    # Load rules, create defaults if missing
#   bd-review-rules-loader --init             # Initialize with default rules
#   bd-review-rules-loader --validate         # Validate existing rules file
#   bd-review-rules-loader --sync-to-config   # Sync JSON rules to bd config
#   bd-review-rules-loader --sync-from-config # Sync bd config to JSON file
#   bd-review-rules-loader --get TYPE         # Get maxAutoPriority for a type
#   bd-review-rules-loader --get-override ID  # Get override for a task
#   bd-review-rules-loader --json             # Output loaded rules as JSON
#
# Schema v1:
#   {
#     "version": 1,
#     "defaultAction": "review" | "auto",
#     "priorityThreshold": 0-4 (global fallback),
#     "rules": [
#       { "type": "bug"|"feature"|"task"|"chore"|"epic",
#         "maxAutoPriority": -1 to 4,
#         "note": "optional explanation" }
#     ],
#     "overrides": [
#       { "taskId": "xxx", "action": "always_review"|"always_auto",
#         "reason": "optional" }
#     ]
#   }

set -e

# Color codes
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Constants
CURRENT_SCHEMA_VERSION=1
VALID_TYPES=("bug" "feature" "task" "chore" "epic")
VALID_ACTIONS=("review" "auto")
VALID_OVERRIDE_ACTIONS=("always_review" "always_auto")

# Default values
DEFAULT_ACTION="review"
DEFAULT_PRIORITY_THRESHOLD=3

# Find .beads directory (walk up tree)
find_beads_dir() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.beads" ]]; then
            echo "$dir/.beads"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    echo ""
    return 1
}

# Get the rules file path
get_rules_file() {
    local beads_dir
    beads_dir=$(find_beads_dir)
    if [[ -z "$beads_dir" ]]; then
        echo -e "${RED}Error: No .beads directory found${NC}" >&2
        echo "Run 'bd init' to initialize a beads repository" >&2
        exit 1
    fi
    echo "$beads_dir/review-rules.json"
}

# Generate default rules JSON
generate_defaults() {
    cat <<EOF
{
  "version": $CURRENT_SCHEMA_VERSION,
  "defaultAction": "$DEFAULT_ACTION",
  "priorityThreshold": $DEFAULT_PRIORITY_THRESHOLD,
  "rules": [
    { "type": "bug", "maxAutoPriority": 3, "note": "P0-P3 bugs auto-proceed, P4 requires review" },
    { "type": "feature", "maxAutoPriority": 3, "note": "P0-P3 features auto-proceed" },
    { "type": "task", "maxAutoPriority": 3 },
    { "type": "chore", "maxAutoPriority": 4, "note": "All chores auto-proceed" },
    { "type": "epic", "maxAutoPriority": -1, "note": "Epics always require review" }
  ],
  "overrides": []
}
EOF
}

# Validate a rules file
validate_rules() {
    local rules_file="$1"
    local errors=()

    if [[ ! -f "$rules_file" ]]; then
        echo -e "${RED}Error: Rules file not found: $rules_file${NC}" >&2
        return 1
    fi

    # Check if valid JSON
    if ! jq empty "$rules_file" 2>/dev/null; then
        echo -e "${RED}Error: Invalid JSON in $rules_file${NC}" >&2
        return 1
    fi

    local rules_json
    rules_json=$(cat "$rules_file")

    # Check version
    local version
    version=$(echo "$rules_json" | jq -r '.version // 0')
    if [[ "$version" -lt 1 ]] || [[ "$version" -gt "$CURRENT_SCHEMA_VERSION" ]]; then
        errors+=("Invalid or unsupported version: $version (expected 1-$CURRENT_SCHEMA_VERSION)")
    fi

    # Check defaultAction
    local default_action
    default_action=$(echo "$rules_json" | jq -r '.defaultAction // ""')
    if [[ -n "$default_action" ]]; then
        local valid_action=false
        for action in "${VALID_ACTIONS[@]}"; do
            if [[ "$default_action" == "$action" ]]; then
                valid_action=true
                break
            fi
        done
        if [[ "$valid_action" == false ]]; then
            errors+=("Invalid defaultAction: '$default_action' (expected: ${VALID_ACTIONS[*]})")
        fi
    fi

    # Check priorityThreshold
    local threshold
    threshold=$(echo "$rules_json" | jq -r '.priorityThreshold // -999')
    if [[ "$threshold" != "null" ]] && [[ "$threshold" != "-999" ]]; then
        if [[ "$threshold" -lt 0 ]] || [[ "$threshold" -gt 4 ]]; then
            errors+=("Invalid priorityThreshold: $threshold (expected: 0-4)")
        fi
    fi

    # Validate rules array
    local rules_count
    rules_count=$(echo "$rules_json" | jq '.rules | length')
    for ((i=0; i<rules_count; i++)); do
        local rule_type rule_max
        rule_type=$(echo "$rules_json" | jq -r ".rules[$i].type // \"\"")
        rule_max=$(echo "$rules_json" | jq -r ".rules[$i].maxAutoPriority // -999")

        # Validate type
        if [[ -n "$rule_type" ]]; then
            local valid_type=false
            for t in "${VALID_TYPES[@]}"; do
                if [[ "$rule_type" == "$t" ]]; then
                    valid_type=true
                    break
                fi
            done
            if [[ "$valid_type" == false ]]; then
                errors+=("rules[$i]: Invalid type '$rule_type' (expected: ${VALID_TYPES[*]})")
            fi
        else
            errors+=("rules[$i]: Missing required field 'type'")
        fi

        # Validate maxAutoPriority
        if [[ "$rule_max" == "-999" ]]; then
            errors+=("rules[$i]: Missing required field 'maxAutoPriority'")
        elif [[ "$rule_max" -lt -1 ]] || [[ "$rule_max" -gt 4 ]]; then
            errors+=("rules[$i]: Invalid maxAutoPriority '$rule_max' (expected: -1 to 4)")
        fi
    done

    # Validate overrides array
    local overrides_count
    overrides_count=$(echo "$rules_json" | jq '.overrides | length // 0')
    for ((i=0; i<overrides_count; i++)); do
        local override_id override_action
        override_id=$(echo "$rules_json" | jq -r ".overrides[$i].taskId // \"\"")
        override_action=$(echo "$rules_json" | jq -r ".overrides[$i].action // \"\"")

        if [[ -z "$override_id" ]]; then
            errors+=("overrides[$i]: Missing required field 'taskId'")
        fi

        if [[ -n "$override_action" ]]; then
            local valid_override=false
            for oa in "${VALID_OVERRIDE_ACTIONS[@]}"; do
                if [[ "$override_action" == "$oa" ]]; then
                    valid_override=true
                    break
                fi
            done
            if [[ "$valid_override" == false ]]; then
                errors+=("overrides[$i]: Invalid action '$override_action' (expected: ${VALID_OVERRIDE_ACTIONS[*]})")
            fi
        else
            errors+=("overrides[$i]: Missing required field 'action'")
        fi
    done

    # Report errors
    if [[ ${#errors[@]} -gt 0 ]]; then
        echo -e "${RED}Validation errors in $rules_file:${NC}" >&2
        for err in "${errors[@]}"; do
            echo -e "  ${RED}•${NC} $err" >&2
        done
        return 1
    fi

    echo -e "${GREEN}✓ Rules file is valid${NC}"
    return 0
}

# Migrate rules from older schema versions
migrate_rules() {
    local rules_file="$1"
    local rules_json
    rules_json=$(cat "$rules_file")

    local version
    version=$(echo "$rules_json" | jq -r '.version // 0')

    if [[ "$version" -eq "$CURRENT_SCHEMA_VERSION" ]]; then
        echo "Rules file is already at version $CURRENT_SCHEMA_VERSION"
        return 0
    fi

    echo -e "${BLUE}Migrating rules from version $version to $CURRENT_SCHEMA_VERSION...${NC}"

    # Migration from v0 (no version) to v1
    if [[ "$version" -lt 1 ]]; then
        # Add version field
        rules_json=$(echo "$rules_json" | jq '. + {version: 1}')

        # Ensure all required fields exist
        rules_json=$(echo "$rules_json" | jq '
            . + {
                defaultAction: (.defaultAction // "review"),
                priorityThreshold: (.priorityThreshold // 3),
                rules: (.rules // []),
                overrides: (.overrides // [])
            }
        ')
    fi

    # Future migrations can go here:
    # if [[ "$version" -lt 2 ]]; then
    #     # v1 → v2 migration
    # fi

    # Write migrated rules
    echo "$rules_json" | jq '.' > "$rules_file"
    echo -e "${GREEN}✓ Migration complete${NC}"
}

# Load rules, creating defaults if missing
load_rules() {
    local rules_file
    rules_file=$(get_rules_file)

    if [[ ! -f "$rules_file" ]]; then
        echo -e "${YELLOW}No review-rules.json found, creating defaults...${NC}" >&2
        generate_defaults > "$rules_file"
        echo -e "${GREEN}✓ Created $rules_file${NC}" >&2
    fi

    # Validate
    if ! validate_rules "$rules_file" >/dev/null 2>&1; then
        echo -e "${YELLOW}Rules file has validation errors, attempting migration...${NC}" >&2
        migrate_rules "$rules_file"
    fi

    cat "$rules_file"
}

# Sync JSON rules to bd config
sync_to_config() {
    local rules_file
    rules_file=$(get_rules_file)

    if [[ ! -f "$rules_file" ]]; then
        echo -e "${RED}Error: No rules file found at $rules_file${NC}" >&2
        echo "Run 'bd-review-rules-loader --init' to create one" >&2
        exit 1
    fi

    local rules_json
    rules_json=$(cat "$rules_file")

    # Sync defaultAction
    local default_action
    default_action=$(echo "$rules_json" | jq -r '.defaultAction // "review"')
    bd config set "review_rules.default_action" "$default_action" >/dev/null 2>&1

    # Sync each type rule
    local rules_count
    rules_count=$(echo "$rules_json" | jq '.rules | length')
    for ((i=0; i<rules_count; i++)); do
        local rule_type rule_max
        rule_type=$(echo "$rules_json" | jq -r ".rules[$i].type")
        rule_max=$(echo "$rules_json" | jq -r ".rules[$i].maxAutoPriority")

        bd config set "review_rules.$rule_type.max_auto" -- "$rule_max" >/dev/null 2>&1
    done

    echo -e "${GREEN}✓ Synced rules to bd config${NC}"
}

# Sync bd config to JSON file
sync_from_config() {
    local rules_file
    rules_file=$(get_rules_file)

    # Start with defaults or existing file
    local rules_json
    if [[ -f "$rules_file" ]]; then
        rules_json=$(cat "$rules_file")
    else
        rules_json=$(generate_defaults)
    fi

    # Get values from bd config
    local default_action
    default_action=$(bd config get "review_rules.default_action" 2>/dev/null || echo "")
    if [[ -n "$default_action" ]] && [[ "$default_action" != *"not set"* ]]; then
        rules_json=$(echo "$rules_json" | jq --arg da "$default_action" '.defaultAction = $da')
    fi

    # Update each type rule
    for t in "${VALID_TYPES[@]}"; do
        local max_auto
        max_auto=$(bd config get "review_rules.$t.max_auto" 2>/dev/null || echo "")
        if [[ -n "$max_auto" ]] && [[ "$max_auto" != *"not set"* ]]; then
            # Update or add the rule
            rules_json=$(echo "$rules_json" | jq --arg type "$t" --argjson max "$max_auto" '
                .rules = [.rules[] | if .type == $type then .maxAutoPriority = $max else . end] |
                if ([.rules[] | select(.type == $type)] | length) == 0 then
                    .rules += [{"type": $type, "maxAutoPriority": $max}]
                else . end
            ')
        fi
    done

    # Write updated rules
    echo "$rules_json" | jq '.' > "$rules_file"
    echo -e "${GREEN}✓ Synced bd config to rules file${NC}"
}

# Get maxAutoPriority for a type
get_type_rule() {
    local type="$1"
    local rules_json
    rules_json=$(load_rules 2>/dev/null)

    local max_auto
    max_auto=$(echo "$rules_json" | jq -r --arg t "$type" '
        (.rules[] | select(.type == $t) | .maxAutoPriority) // .priorityThreshold // 3
    ')

    echo "$max_auto"
}

# Get override for a task
get_override() {
    local task_id="$1"
    local rules_json
    rules_json=$(load_rules 2>/dev/null)

    local override
    override=$(echo "$rules_json" | jq -r --arg id "$task_id" '
        .overrides[] | select(.taskId == $id) | .action
    ')

    if [[ -z "$override" ]] || [[ "$override" == "null" ]]; then
        echo "none"
    else
        echo "$override"
    fi
}

# Parse arguments
ACTION="load"
TYPE_QUERY=""
OVERRIDE_QUERY=""
JSON_OUTPUT=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --init|-i)
            ACTION="init"
            shift
            ;;
        --validate|-v)
            ACTION="validate"
            shift
            ;;
        --sync-to-config)
            ACTION="sync_to"
            shift
            ;;
        --sync-from-config)
            ACTION="sync_from"
            shift
            ;;
        --get|-g)
            ACTION="get_type"
            TYPE_QUERY="$2"
            shift 2
            ;;
        --get-override)
            ACTION="get_override"
            OVERRIDE_QUERY="$2"
            shift 2
            ;;
        --json|-j)
            JSON_OUTPUT=true
            shift
            ;;
        --help|-h)
            echo "bd-review-rules-loader - Load and manage review-rules.json"
            echo ""
            echo "Usage:"
            echo "  bd-review-rules-loader                    Load rules (create defaults if missing)"
            echo "  bd-review-rules-loader --init             Initialize with default rules"
            echo "  bd-review-rules-loader --validate         Validate existing rules file"
            echo "  bd-review-rules-loader --sync-to-config   Sync JSON rules to bd config"
            echo "  bd-review-rules-loader --sync-from-config Sync bd config to JSON file"
            echo "  bd-review-rules-loader --get TYPE         Get maxAutoPriority for a type"
            echo "  bd-review-rules-loader --get-override ID  Get override for a task"
            echo "  bd-review-rules-loader --json             Output loaded rules as JSON"
            echo ""
            echo "Schema (v$CURRENT_SCHEMA_VERSION):"
            echo "  version           Schema version (currently $CURRENT_SCHEMA_VERSION)"
            echo "  defaultAction     Default action: 'review' or 'auto'"
            echo "  priorityThreshold Global fallback priority threshold (0-4)"
            echo "  rules[]           Type-specific rules:"
            echo "    .type           Task type: bug, feature, task, chore, epic"
            echo "    .maxAutoPriority Max priority that auto-proceeds (-1 to 4)"
            echo "    .note           Optional explanation"
            echo "  overrides[]       Task-specific overrides:"
            echo "    .taskId         Task ID to override"
            echo "    .action         'always_review' or 'always_auto'"
            echo "    .reason         Optional explanation"
            echo ""
            echo "Priority levels:"
            echo "  -1 = Never auto-proceed (all require review)"
            echo "   0 = Only P0 (Critical) auto-proceeds"
            echo "   1 = P0-P1 auto-proceed"
            echo "   2 = P0-P2 auto-proceed"
            echo "   3 = P0-P3 auto-proceed (default)"
            echo "   4 = All priorities auto-proceed"
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}" >&2
            echo "Use --help for usage information" >&2
            exit 1
            ;;
    esac
done

# Execute action
case $ACTION in
    load)
        rules=$(load_rules)
        if [[ "$JSON_OUTPUT" == true ]]; then
            echo "$rules" | jq '.'
        else
            # Pretty print summary
            echo ""
            echo -e "${BOLD}Review Rules (v$(echo "$rules" | jq -r '.version'))${NC}"
            echo ""
            echo -e "  ${CYAN}Default action:${NC} $(echo "$rules" | jq -r '.defaultAction')"
            echo -e "  ${CYAN}Priority threshold:${NC} P$(echo "$rules" | jq -r '.priorityThreshold')"
            echo ""
            echo -e "  ${CYAN}Type rules:${NC}"
            echo "$rules" | jq -r '.rules[] | "    \(.type): maxAutoPriority=\(.maxAutoPriority)\(if .note then " (\(.note))" else "" end)"'
            echo ""
            override_count=$(echo "$rules" | jq '.overrides | length')
            if [[ "$override_count" -gt 0 ]]; then
                echo -e "  ${CYAN}Overrides:${NC}"
                echo "$rules" | jq -r '.overrides[] | "    \(.taskId): \(.action)\(if .reason then " (\(.reason))" else "" end)"'
            else
                echo -e "  ${DIM}No task-specific overrides${NC}"
            fi
            echo ""
        fi
        ;;
    init)
        rules_file=$(get_rules_file)
        if [[ -f "$rules_file" ]]; then
            echo -e "${YELLOW}Rules file already exists: $rules_file${NC}"
            read -p "Overwrite with defaults? [y/N] " confirm
            if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
                echo "Aborted"
                exit 0
            fi
        fi
        generate_defaults > "$rules_file"
        echo -e "${GREEN}✓ Created $rules_file${NC}"
        ;;
    validate)
        rules_file=$(get_rules_file)
        validate_rules "$rules_file"
        ;;
    sync_to)
        sync_to_config
        ;;
    sync_from)
        sync_from_config
        ;;
    get_type)
        if [[ -z "$TYPE_QUERY" ]]; then
            echo -e "${RED}Error: --get requires a type argument${NC}" >&2
            exit 1
        fi
        get_type_rule "$TYPE_QUERY"
        ;;
    get_override)
        if [[ -z "$OVERRIDE_QUERY" ]]; then
            echo -e "${RED}Error: --get-override requires a task ID argument${NC}" >&2
            exit 1
        fi
        get_override "$OVERRIDE_QUERY"
        ;;
esac
