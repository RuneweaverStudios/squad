#!/usr/bin/env bash
#
# jat-signal-validate - Validate signal payloads against JSON schema
#
# Usage:
#   jat-signal-validate complete '{...}'
#   jat-signal-validate working '{"taskId":"...","taskTitle":"..."}'
#   jat-signal-validate review '{"taskId":"...","summary":[...]}'
#   jat-signal-validate needs_input '{"taskId":"...","question":"..."}'
#   jat-signal-validate idle '{"readyForWork":true,...}'
#   jat-signal-validate completing '{"taskId":"...","currentStep":"..."}'
#   jat-signal-validate starting '{"agentName":"...",...}'
#   jat-signal-validate compacting '{"reason":"...","contextSizeBefore":...}'
#   jat-signal-validate question '{"question":"...","questionType":"choice",...}'
#
# Returns:
#   0 - Valid payload
#   1 - Invalid payload (error message on stderr)
#   2 - Missing jq or invalid arguments

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCHEMA_FILE="${SCRIPT_DIR}/jat-signal-schema.json"

SIGNAL_TYPE="${1:-}"
PAYLOAD="${2:-}"

# =============================================================================
# Actionable Error Helper Functions
# =============================================================================

# Generate an actionable error message with context and example
# Usage: error_missing_field "signal_type" "field_name" ["example_value"]
error_missing_field() {
    local signal_type="$1"
    local field="$2"
    local example="${3:-}"

    echo "Error: ${signal_type} signal missing required field '${field}'" >&2

    # Show example based on signal type and field
    case "${signal_type}:${field}" in
        working:taskId)
            echo "  Expected: \"taskId\": \"jat-abc\" (your JAT task ID)" >&2
            ;;
        working:taskTitle)
            echo "  Expected: \"taskTitle\": \"Fix authentication bug\"" >&2
            ;;
        review:taskId)
            echo "  Expected: \"taskId\": \"jat-abc\" (the task you worked on)" >&2
            ;;
        review:taskTitle)
            echo "  Expected: \"taskTitle\": \"Fix authentication bug\"" >&2
            ;;
        review:summary)
            echo "  Expected: \"summary\": [\"Fixed login flow\", \"Added error handling\"]" >&2
            ;;
        needs_input:taskId)
            echo "  Expected: \"taskId\": \"jat-abc\" (the task you're blocked on)" >&2
            ;;
        needs_input:question)
            echo "  Expected: \"question\": \"Which authentication method should I use?\"" >&2
            ;;
        needs_input:questionType)
            echo "  Expected: \"questionType\": \"choice\" (one of: choice, text, approval, clarification)" >&2
            ;;
        starting:agentName)
            echo "  Expected: \"agentName\": \"FairBay\" (your agent name)" >&2
            ;;
        starting:sessionId)
            echo "  Expected: \"sessionId\": \"abc123-def456-...\" (from get-current-session-id)" >&2
            ;;
        starting:project)
            echo "  Expected: \"project\": \"jat\" (project directory name)" >&2
            ;;
        starting:model)
            echo "  Expected: \"model\": \"claude-opus-4-5-20251101\" (full model ID)" >&2
            ;;
        starting:gitBranch)
            echo "  Expected: \"gitBranch\": \"master\" (current git branch)" >&2
            ;;
        starting:gitStatus)
            echo "  Expected: \"gitStatus\": \"clean\" (one of: clean, dirty)" >&2
            ;;
        completing:taskId)
            echo "  Expected: \"taskId\": \"jat-abc\" (the task being completed)" >&2
            ;;
        completing:currentStep)
            echo "  Expected: \"currentStep\": \"committing\" (one of: verifying, committing, closing, releasing, announcing)" >&2
            ;;
        compacting:reason)
            echo "  Expected: \"reason\": \"Context window approaching limit\"" >&2
            ;;
        compacting:contextSizeBefore)
            echo "  Expected: \"contextSizeBefore\": 180000 (token count before compaction)" >&2
            ;;
        idle:readyForWork)
            echo "  Expected: \"readyForWork\": true (boolean)" >&2
            ;;
        question:question)
            echo "  Expected: \"question\": \"Which option do you prefer?\"" >&2
            ;;
        question:questionType)
            echo "  Expected: \"questionType\": \"choice\" (one of: choice, confirm, input)" >&2
            ;;
        reply:taskId)
            echo "  Expected: \"taskId\": \"jat-abc\" (task that originated from a channel message)" >&2
            ;;
        reply:message)
            echo "  Expected: \"message\": \"Got it, working on the login fix\"" >&2
            ;;
        reply:replyType)
            echo "  Expected: \"replyType\": \"ack\" (one of: ack, progress, question, completion)" >&2
            ;;
        *)
            if [[ -n "$example" ]]; then
                echo "  Expected: \"${field}\": ${example}" >&2
            fi
            ;;
    esac

    return 1
}

# Show required fields for a signal type
show_required_fields() {
    local signal_type="$1"

    echo "" >&2
    case "$signal_type" in
        working)
            echo "Required fields for 'working' signal:" >&2
            echo "  - taskId: The JAT task ID (e.g., \"jat-abc\")" >&2
            echo "  - taskTitle: The task title" >&2
            echo "" >&2
            echo "Example:" >&2
            echo "  jat-signal working '{\"taskId\":\"jat-abc\",\"taskTitle\":\"Fix bug\",\"approach\":\"...\"}'" >&2
            ;;
        review)
            echo "Required fields for 'review' signal:" >&2
            echo "  - taskId: The JAT task ID" >&2
            echo "  - taskTitle: The task title" >&2
            echo "  - summary: Array of accomplishment strings" >&2
            echo "" >&2
            echo "Example:" >&2
            echo "  jat-signal review '{\"taskId\":\"jat-abc\",\"taskTitle\":\"Fix bug\",\"summary\":[\"Fixed the issue\"]}'" >&2
            ;;
        needs_input)
            echo "Required fields for 'needs_input' signal:" >&2
            echo "  - taskId: The JAT task ID" >&2
            echo "  - question: The question being asked" >&2
            echo "  - questionType: One of: choice, text, approval, clarification" >&2
            echo "" >&2
            echo "Example:" >&2
            echo "  jat-signal needs_input '{\"taskId\":\"jat-abc\",\"question\":\"Which approach?\",\"questionType\":\"choice\"}'" >&2
            ;;
        starting)
            echo "Required fields for 'starting' signal:" >&2
            echo "  - agentName: Your agent name" >&2
            echo "  - sessionId: Claude Code session ID (from get-current-session-id)" >&2
            echo "  - project: Project name (e.g., \"jat\")" >&2
            echo "  - model: Full model ID (e.g., \"claude-opus-4-5-20251101\")" >&2
            echo "  - gitBranch: Current git branch" >&2
            echo "  - gitStatus: \"clean\" or \"dirty\"" >&2
            echo "" >&2
            echo "Example:" >&2
            echo "  jat-signal starting '{\"agentName\":\"Agent\",\"sessionId\":\"...\",\"project\":\"jat\",\"model\":\"claude-opus-4-5-20251101\",\"gitBranch\":\"master\",\"gitStatus\":\"clean\",\"tools\":[],\"uncommittedFiles\":[]}'" >&2
            ;;
        completing)
            echo "Required fields for 'completing' signal:" >&2
            echo "  - taskId: The JAT task ID" >&2
            echo "  - currentStep: One of: verifying, committing, closing, releasing, announcing" >&2
            echo "" >&2
            echo "Example:" >&2
            echo "  jat-signal completing '{\"taskId\":\"jat-abc\",\"currentStep\":\"committing\"}'" >&2
            ;;
        compacting)
            echo "Required fields for 'compacting' signal:" >&2
            echo "  - reason: Why compaction is happening" >&2
            echo "  - contextSizeBefore: Token count before compaction" >&2
            echo "" >&2
            echo "Example:" >&2
            echo "  jat-signal compacting '{\"reason\":\"Approaching limit\",\"contextSizeBefore\":180000}'" >&2
            ;;
        idle)
            echo "Required fields for 'idle' signal:" >&2
            echo "  - readyForWork: Boolean (true/false)" >&2
            echo "" >&2
            echo "Example:" >&2
            echo "  jat-signal idle '{\"readyForWork\":true}'" >&2
            ;;
        question)
            echo "Required fields for 'question' signal:" >&2
            echo "  - question: The question text" >&2
            echo "  - questionType: One of: choice, confirm, input" >&2
            echo "" >&2
            echo "Example:" >&2
            echo "  jat-signal question '{\"question\":\"Continue?\",\"questionType\":\"confirm\"}'" >&2
            ;;
        reply)
            echo "Required fields for 'reply' signal:" >&2
            echo "  - taskId: The JAT task ID (must originate from a channel message)" >&2
            echo "  - message: Text to send to the originating channel" >&2
            echo "  - replyType: One of: ack, progress, question, completion" >&2
            echo "" >&2
            echo "Example:" >&2
            echo "  jat-signal reply '{\"taskId\":\"jat-abc\",\"message\":\"Working on it\",\"replyType\":\"ack\"}'" >&2
            ;;
    esac
}

# Helper to check a required string field exists and is non-empty
# Returns 0 if valid, 1 if missing/empty (with error output)
require_string_field() {
    local payload="$1"
    local signal_type="$2"
    local field="$3"

    if ! echo "$payload" | jq -e "has(\"$field\")" >/dev/null 2>&1; then
        error_missing_field "$signal_type" "$field"
        show_required_fields "$signal_type"
        return 1
    fi

    local value
    value=$(echo "$payload" | jq -r ".$field // \"\"")
    if [[ -z "$value" ]]; then
        echo "Error: ${signal_type}.${field} cannot be empty" >&2
        show_required_fields "$signal_type"
        return 1
    fi

    return 0
}

# Helper to check a required array field exists
require_array_field() {
    local payload="$1"
    local signal_type="$2"
    local field="$3"

    if ! echo "$payload" | jq -e "has(\"$field\")" >/dev/null 2>&1; then
        error_missing_field "$signal_type" "$field"
        show_required_fields "$signal_type"
        return 1
    fi

    if ! echo "$payload" | jq -e ".$field | type == \"array\"" >/dev/null 2>&1; then
        echo "Error: ${signal_type}.${field} must be an array" >&2
        show_required_fields "$signal_type"
        return 1
    fi

    return 0
}

# Helper to check a required boolean field exists
require_boolean_field() {
    local payload="$1"
    local signal_type="$2"
    local field="$3"

    if ! echo "$payload" | jq -e "has(\"$field\")" >/dev/null 2>&1; then
        error_missing_field "$signal_type" "$field"
        show_required_fields "$signal_type"
        return 1
    fi

    if ! echo "$payload" | jq -e ".$field | type == \"boolean\"" >/dev/null 2>&1; then
        echo "Error: ${signal_type}.${field} must be a boolean (true/false)" >&2
        show_required_fields "$signal_type"
        return 1
    fi

    return 0
}

# Helper to check a required integer field exists
require_integer_field() {
    local payload="$1"
    local signal_type="$2"
    local field="$3"
    local min="${4:-}"
    local max="${5:-}"

    if ! echo "$payload" | jq -e "has(\"$field\")" >/dev/null 2>&1; then
        error_missing_field "$signal_type" "$field"
        show_required_fields "$signal_type"
        return 1
    fi

    local value
    value=$(echo "$payload" | jq ".$field // null")

    if [[ "$value" == "null" ]] || ! echo "$value" | grep -qE '^-?[0-9]+$'; then
        echo "Error: ${signal_type}.${field} must be an integer" >&2
        show_required_fields "$signal_type"
        return 1
    fi

    if [[ -n "$min" ]] && [[ "$value" -lt "$min" ]]; then
        echo "Error: ${signal_type}.${field} must be >= ${min}" >&2
        return 1
    fi

    if [[ -n "$max" ]] && [[ "$value" -gt "$max" ]]; then
        echo "Error: ${signal_type}.${field} must be <= ${max}" >&2
        return 1
    fi

    return 0
}

show_usage() {
    echo "Usage: jat-signal-validate <signal-type> <json-payload>"
    echo ""
    echo "Signal Types:"
    echo "  complete    - Validate completion bundle object"
    echo "  working     - Validate rich working signal"
    echo "  review      - Validate rich review signal"
    echo "  needs_input - Validate rich needs_input signal"
    echo "  idle        - Validate rich idle signal"
    echo "  completing  - Validate rich completing signal"
    echo "  starting    - Validate rich starting signal"
    echo "  compacting  - Validate rich compacting signal"
    echo "  question    - Validate question signal for IDE"
    echo "  reply       - Validate reply signal for two-way routing"
    echo ""
    echo "Examples:"
    echo "  jat-signal-validate complete '{\"taskId\":\"jat-abc\",\"agentName\":\"Agent\"}'"
    echo "  jat-signal-validate working '{\"taskId\":\"jat-abc\",\"taskTitle\":\"Fix bug\"}'"
    echo "  jat-signal-validate review '{\"taskId\":\"jat-abc\",\"summary\":[\"Fixed the bug\"]}'"
}

if [[ -z "$SIGNAL_TYPE" ]] || [[ -z "$PAYLOAD" ]]; then
    show_usage
    exit 2
fi

# Check jq is available
if ! command -v jq &>/dev/null; then
    echo "Error: jq is required for validation" >&2
    exit 2
fi

# First, check if payload is valid JSON
if ! echo "$PAYLOAD" | jq . >/dev/null 2>&1; then
    echo "Error: Invalid JSON syntax" >&2
    exit 1
fi

# Define validation functions for each signal type
# Since we can't use ajv or jsonschema in bash, we implement basic validation with jq

validate_quality_signals() {
    local payload="$1"
    local prefix="$2"

    # Validate tests if present
    local tests
    tests=$(echo "$payload" | jq -r '.tests // ""')
    if [[ -n "$tests" ]]; then
        case "$tests" in
            passing|failing|none|skipped) ;;
            *)
                echo "Error: ${prefix}quality.tests must be one of: passing, failing, none, skipped" >&2
                return 1
                ;;
        esac
    fi

    # Validate build if present
    local build
    build=$(echo "$payload" | jq -r '.build // ""')
    if [[ -n "$build" ]]; then
        case "$build" in
            clean|warnings|errors) ;;
            *)
                echo "Error: ${prefix}quality.build must be one of: clean, warnings, errors" >&2
                return 1
                ;;
        esac
    fi

    # Check for unknown fields
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["tests","build","preExisting"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: ${prefix}quality has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

validate_cross_agent_intel() {
    local payload="$1"
    local prefix="$2"

    # Validate files is array of strings if present
    if echo "$payload" | jq -e 'has("files")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.files | type == "array"' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.files must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.files | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.files must contain only strings" >&2
            return 1
        fi
    fi

    # Validate patterns is array of strings if present
    if echo "$payload" | jq -e 'has("patterns")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.patterns | type == "array"' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.patterns must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.patterns | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.patterns must contain only strings" >&2
            return 1
        fi
    fi

    # Validate gotchas is array of strings if present
    if echo "$payload" | jq -e 'has("gotchas")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.gotchas | type == "array"' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.gotchas must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.gotchas | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.gotchas must contain only strings" >&2
            return 1
        fi
    fi

    # Check for unknown fields
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["files","patterns","gotchas"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: ${prefix}crossAgentIntel has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

# =============================================================================
# Rich State Signal Validators
# =============================================================================

validate_working() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: working signal must be a JSON object" >&2
        show_required_fields "working"
        return 1
    fi

    # Required: taskId (string, non-empty)
    require_string_field "$payload" "working" "taskId" || return 1

    # Required: taskTitle (string, non-empty) - per schema
    require_string_field "$payload" "working" "taskTitle" || return 1

    # Validate taskPriority if present
    local priority
    priority=$(echo "$payload" | jq '.taskPriority // null')
    if [[ "$priority" != "null" ]]; then
        if ! echo "$priority" | grep -qE '^[0-4]$'; then
            echo "Error: working.taskPriority must be 0-4" >&2
            return 1
        fi
    fi

    # Validate estimatedScope if present
    local scope
    scope=$(echo "$payload" | jq -r '.estimatedScope // ""')
    if [[ -n "$scope" ]]; then
        case "$scope" in
            small|medium|large) ;;
            *)
                echo "Error: working.estimatedScope must be one of: small, medium, large" >&2
                return 1
                ;;
        esac
    fi

    # Validate expectedFiles is array if present
    if echo "$payload" | jq -e 'has("expectedFiles")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.expectedFiles | type == "array"' >/dev/null 2>&1; then
            echo "Error: working.expectedFiles must be an array" >&2
            return 1
        fi
    fi

    # Validate dependencies is array if present
    if echo "$payload" | jq -e 'has("dependencies")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.dependencies | type == "array"' >/dev/null 2>&1; then
            echo "Error: working.dependencies must be an array" >&2
            return 1
        fi
    fi

    return 0
}

validate_review() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: review signal must be a JSON object" >&2
        show_required_fields "review"
        return 1
    fi

    # Required: taskId (string, non-empty)
    require_string_field "$payload" "review" "taskId" || return 1

    # Required: taskTitle (string, non-empty) - per schema
    require_string_field "$payload" "review" "taskTitle" || return 1

    # Required: summary (array) - per schema
    require_array_field "$payload" "review" "summary" || return 1

    # Additional validation: summary must contain only strings
    if ! echo "$payload" | jq -e '.summary | all(type == "string")' >/dev/null 2>&1; then
        echo "Error: review.summary must contain only strings" >&2
        echo "  Expected: \"summary\": [\"Fixed bug\", \"Added tests\"]" >&2
        return 1
    fi

    # Validate testsStatus if present
    local tests_status
    tests_status=$(echo "$payload" | jq -r '.testsStatus // ""')
    if [[ -n "$tests_status" ]]; then
        case "$tests_status" in
            passing|failing|none|skipped) ;;
            *)
                echo "Error: review.testsStatus must be one of: passing, failing, none, skipped" >&2
                return 1
                ;;
        esac
    fi

    # Validate buildStatus if present
    local build_status
    build_status=$(echo "$payload" | jq -r '.buildStatus // ""')
    if [[ -n "$build_status" ]]; then
        case "$build_status" in
            clean|warnings|errors) ;;
            *)
                echo "Error: review.buildStatus must be one of: clean, warnings, errors" >&2
                return 1
                ;;
        esac
    fi

    # Validate filesModified is array if present
    if echo "$payload" | jq -e 'has("filesModified")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.filesModified | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.filesModified must be an array" >&2
            return 1
        fi
        # Validate each file modification object
        local count
        count=$(echo "$payload" | jq '.filesModified | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local file_mod
            file_mod=$(echo "$payload" | jq ".filesModified[$i]")

            # path is required
            if ! echo "$file_mod" | jq -e 'has("path")' >/dev/null 2>&1; then
                echo "Error: review.filesModified[$i] missing required field 'path'" >&2
                return 1
            fi

            # changeType if present must be valid
            local change_type
            change_type=$(echo "$file_mod" | jq -r '.changeType // ""')
            if [[ -n "$change_type" ]]; then
                case "$change_type" in
                    added|modified|deleted) ;;
                    *)
                        echo "Error: review.filesModified[$i].changeType must be one of: added, modified, deleted" >&2
                        return 1
                        ;;
                esac
            fi

            i=$((i + 1))
        done
    fi

    # Validate keyDecisions is array if present
    if echo "$payload" | jq -e 'has("keyDecisions")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.keyDecisions | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.keyDecisions must be an array" >&2
            return 1
        fi
        # Validate each key decision has decision field
        local count
        count=$(echo "$payload" | jq '.keyDecisions | length')
        local i=0
        while [[ $i -lt $count ]]; do
            if ! echo "$payload" | jq -e ".keyDecisions[$i] | has(\"decision\")" >/dev/null 2>&1; then
                echo "Error: review.keyDecisions[$i] missing required field 'decision'" >&2
                return 1
            fi
            i=$((i + 1))
        done
    fi

    # Validate reviewFocus is array of strings or objects with 'text' field if present
    if echo "$payload" | jq -e 'has("reviewFocus")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.reviewFocus | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.reviewFocus must be an array" >&2
            return 1
        fi
        # Each item must be either a string or an object with 'text' field
        local count
        count=$(echo "$payload" | jq '.reviewFocus | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local item
            item=$(echo "$payload" | jq ".reviewFocus[$i]")
            local item_type
            item_type=$(echo "$item" | jq -r 'type')

            if [[ "$item_type" == "string" ]]; then
                # String item is valid
                :
            elif [[ "$item_type" == "object" ]]; then
                # Object must have 'text' field
                if ! echo "$item" | jq -e 'has("text")' >/dev/null 2>&1; then
                    echo "Error: review.reviewFocus[$i] object missing required field 'text'" >&2
                    return 1
                fi
                local text
                text=$(echo "$item" | jq -r '.text // ""')
                if [[ -z "$text" ]]; then
                    echo "Error: review.reviewFocus[$i].text cannot be empty" >&2
                    return 1
                fi
                # Validate optional fields
                if echo "$item" | jq -e 'has("line")' >/dev/null 2>&1; then
                    local line
                    line=$(echo "$item" | jq '.line')
                    if ! echo "$line" | grep -qE '^[1-9][0-9]*$'; then
                        echo "Error: review.reviewFocus[$i].line must be a positive integer" >&2
                        return 1
                    fi
                fi
                # Check for unknown fields
                local unknown
                unknown=$(echo "$item" | jq -r 'keys - ["text","filePath","localhostRoute","line"] | .[0] // ""')
                if [[ -n "$unknown" ]]; then
                    echo "Error: review.reviewFocus[$i] has unknown field '$unknown'" >&2
                    return 1
                fi
            else
                echo "Error: review.reviewFocus[$i] must be a string or object with 'text' field" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate knownLimitations is array of strings if present
    if echo "$payload" | jq -e 'has("knownLimitations")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.knownLimitations | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.knownLimitations must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.knownLimitations | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: review.knownLimitations must contain only strings" >&2
            return 1
        fi
    fi

    # Validate buildWarnings is array of strings if present
    if echo "$payload" | jq -e 'has("buildWarnings")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.buildWarnings | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.buildWarnings must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.buildWarnings | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: review.buildWarnings must contain only strings" >&2
            return 1
        fi
    fi

    # Validate commits is array if present
    if echo "$payload" | jq -e 'has("commits")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.commits | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.commits must be an array" >&2
            return 1
        fi
        # Validate each commit has sha and message
        local count
        count=$(echo "$payload" | jq '.commits | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local commit
            commit=$(echo "$payload" | jq ".commits[$i]")
            if ! echo "$commit" | jq -e 'has("sha")' >/dev/null 2>&1; then
                echo "Error: review.commits[$i] missing required field 'sha'" >&2
                return 1
            fi
            if ! echo "$commit" | jq -e 'has("message")' >/dev/null 2>&1; then
                echo "Error: review.commits[$i] missing required field 'message'" >&2
                return 1
            fi
            i=$((i + 1))
        done
    fi

    # Validate numeric fields if present
    local total_added total_removed tests_run tests_passed
    total_added=$(echo "$payload" | jq '.totalLinesAdded // null')
    total_removed=$(echo "$payload" | jq '.totalLinesRemoved // null')
    tests_run=$(echo "$payload" | jq '.testsRun // null')
    tests_passed=$(echo "$payload" | jq '.testsPassed // null')

    if [[ "$total_added" != "null" ]] && ! echo "$total_added" | grep -qE '^[0-9]+$'; then
        echo "Error: review.totalLinesAdded must be a non-negative integer" >&2
        return 1
    fi
    if [[ "$total_removed" != "null" ]] && ! echo "$total_removed" | grep -qE '^[0-9]+$'; then
        echo "Error: review.totalLinesRemoved must be a non-negative integer" >&2
        return 1
    fi
    if [[ "$tests_run" != "null" ]] && ! echo "$tests_run" | grep -qE '^[0-9]+$'; then
        echo "Error: review.testsRun must be a non-negative integer" >&2
        return 1
    fi
    if [[ "$tests_passed" != "null" ]] && ! echo "$tests_passed" | grep -qE '^[0-9]+$'; then
        echo "Error: review.testsPassed must be a non-negative integer" >&2
        return 1
    fi

    return 0
}

validate_needs_input() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: needs_input signal must be a JSON object" >&2
        show_required_fields "needs_input"
        return 1
    fi

    # Required: taskId (string, non-empty)
    require_string_field "$payload" "needs_input" "taskId" || return 1

    # Required: question (string, non-empty)
    require_string_field "$payload" "needs_input" "question" || return 1

    # Required: questionType (must be valid enum value)
    if ! echo "$payload" | jq -e 'has("questionType")' >/dev/null 2>&1; then
        error_missing_field "needs_input" "questionType"
        show_required_fields "needs_input"
        return 1
    fi

    local question_type
    question_type=$(echo "$payload" | jq -r '.questionType // ""')
    case "$question_type" in
        choice|text|approval|clarification) ;;
        "")
            echo "Error: needs_input.questionType cannot be empty" >&2
            echo "  Expected: \"questionType\": \"choice\" (one of: choice, text, approval, clarification)" >&2
            show_required_fields "needs_input"
            return 1
            ;;
        *)
            echo "Error: needs_input.questionType must be one of: choice, text, approval, clarification" >&2
            echo "  Got: \"$question_type\"" >&2
            return 1
            ;;
    esac

    # Validate options is array if present
    if echo "$payload" | jq -e 'has("options")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.options | type == "array"' >/dev/null 2>&1; then
            echo "Error: needs_input.options must be an array" >&2
            return 1
        fi
    fi

    return 0
}

validate_idle() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: idle signal must be a JSON object" >&2
        show_required_fields "idle"
        return 1
    fi

    # Required: readyForWork (boolean)
    require_boolean_field "$payload" "idle" "readyForWork" || return 1

    # Validate sessionSummary if present
    if echo "$payload" | jq -e 'has("sessionSummary")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.sessionSummary | type == "object"' >/dev/null 2>&1; then
            echo "Error: idle.sessionSummary must be an object" >&2
            return 1
        fi

        local session_summary
        session_summary=$(echo "$payload" | jq '.sessionSummary')

        # Validate tasksCompleted is array of strings if present
        if echo "$session_summary" | jq -e 'has("tasksCompleted")' >/dev/null 2>&1; then
            if ! echo "$session_summary" | jq -e '.tasksCompleted | type == "array"' >/dev/null 2>&1; then
                echo "Error: idle.sessionSummary.tasksCompleted must be an array" >&2
                return 1
            fi
            if ! echo "$session_summary" | jq -e '.tasksCompleted | all(type == "string")' >/dev/null 2>&1; then
                echo "Error: idle.sessionSummary.tasksCompleted must contain only strings" >&2
                return 1
            fi
        fi

        # Validate numeric fields if present
        local total_duration tokens_used files_modified
        total_duration=$(echo "$session_summary" | jq '.totalDuration // null')
        tokens_used=$(echo "$session_summary" | jq '.tokensUsed // null')
        files_modified=$(echo "$session_summary" | jq '.filesModified // null')

        if [[ "$total_duration" != "null" ]] && ! echo "$total_duration" | grep -qE '^[0-9]+$'; then
            echo "Error: idle.sessionSummary.totalDuration must be a non-negative integer" >&2
            return 1
        fi
        if [[ "$tokens_used" != "null" ]] && ! echo "$tokens_used" | grep -qE '^[0-9]+$'; then
            echo "Error: idle.sessionSummary.tokensUsed must be a non-negative integer" >&2
            return 1
        fi
        if [[ "$files_modified" != "null" ]] && ! echo "$files_modified" | grep -qE '^[0-9]+$'; then
            echo "Error: idle.sessionSummary.filesModified must be a non-negative integer" >&2
            return 1
        fi

        # Check for unknown fields in sessionSummary
        local unknown
        unknown=$(echo "$session_summary" | jq -r 'keys - ["tasksCompleted","totalDuration","tokensUsed","filesModified"] | .[0] // ""')
        if [[ -n "$unknown" ]]; then
            echo "Error: idle.sessionSummary has unknown field '$unknown'" >&2
            return 1
        fi
    fi

    # Validate suggestedNextTask if present
    if echo "$payload" | jq -e 'has("suggestedNextTask")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.suggestedNextTask | type == "object"' >/dev/null 2>&1; then
            echo "Error: idle.suggestedNextTask must be an object" >&2
            return 1
        fi

        local suggested_next
        suggested_next=$(echo "$payload" | jq '.suggestedNextTask')

        # Required fields: taskId, title, reason
        if ! echo "$suggested_next" | jq -e 'has("taskId")' >/dev/null 2>&1; then
            echo "Error: idle.suggestedNextTask missing required field 'taskId'" >&2
            return 1
        fi
        local task_id
        task_id=$(echo "$suggested_next" | jq -r '.taskId // ""')
        if [[ -z "$task_id" ]]; then
            echo "Error: idle.suggestedNextTask.taskId cannot be empty" >&2
            return 1
        fi

        if ! echo "$suggested_next" | jq -e 'has("title")' >/dev/null 2>&1; then
            echo "Error: idle.suggestedNextTask missing required field 'title'" >&2
            return 1
        fi
        local title
        title=$(echo "$suggested_next" | jq -r '.title // ""')
        if [[ -z "$title" ]]; then
            echo "Error: idle.suggestedNextTask.title cannot be empty" >&2
            return 1
        fi

        if ! echo "$suggested_next" | jq -e 'has("reason")' >/dev/null 2>&1; then
            echo "Error: idle.suggestedNextTask missing required field 'reason'" >&2
            return 1
        fi
        local reason
        reason=$(echo "$suggested_next" | jq -r '.reason // ""')
        if [[ -z "$reason" ]]; then
            echo "Error: idle.suggestedNextTask.reason cannot be empty" >&2
            return 1
        fi

        # Check for unknown fields in suggestedNextTask
        local unknown
        unknown=$(echo "$suggested_next" | jq -r 'keys - ["taskId","title","reason"] | .[0] // ""')
        if [[ -n "$unknown" ]]; then
            echo "Error: idle.suggestedNextTask has unknown field '$unknown'" >&2
            return 1
        fi
    fi

    # Validate blockedReason if present
    if echo "$payload" | jq -e 'has("blockedReason")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.blockedReason | type == "string"' >/dev/null 2>&1; then
            echo "Error: idle.blockedReason must be a string" >&2
            return 1
        fi
    fi

    # Check for unknown fields in idle signal
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["readyForWork","sessionSummary","suggestedNextTask","blockedReason"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: idle signal has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

validate_completing() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: completing signal must be a JSON object" >&2
        show_required_fields "completing"
        return 1
    fi

    # Required: taskId (string, non-empty)
    require_string_field "$payload" "completing" "taskId" || return 1

    # Required: currentStep (must be valid enum value)
    if ! echo "$payload" | jq -e 'has("currentStep")' >/dev/null 2>&1; then
        error_missing_field "completing" "currentStep"
        show_required_fields "completing"
        return 1
    fi

    local current_step
    current_step=$(echo "$payload" | jq -r '.currentStep // ""')
    case "$current_step" in
        verifying|committing|closing|releasing|announcing) ;;
        "")
            echo "Error: completing.currentStep cannot be empty" >&2
            echo "  Expected: \"currentStep\": \"committing\" (one of: verifying, committing, closing, releasing, announcing)" >&2
            show_required_fields "completing"
            return 1
            ;;
        *)
            echo "Error: completing.currentStep must be one of: verifying, committing, closing, releasing, announcing" >&2
            echo "  Got: \"$current_step\"" >&2
            return 1
            ;;
    esac

    # Validate progress is 0-100 if present
    local progress
    progress=$(echo "$payload" | jq '.progress // null')
    if [[ "$progress" != "null" ]]; then
        if ! echo "$progress" | grep -qE '^[0-9]+$' || [[ "$progress" -lt 0 ]] || [[ "$progress" -gt 100 ]]; then
            echo "Error: completing.progress must be 0-100" >&2
            return 1
        fi
    fi

    return 0
}

validate_starting() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: starting signal must be a JSON object" >&2
        show_required_fields "starting"
        return 1
    fi

    # Required: agentName (string, non-empty)
    require_string_field "$payload" "starting" "agentName" || return 1

    # Required: sessionId (string, non-empty) - per schema
    require_string_field "$payload" "starting" "sessionId" || return 1

    # Required: project (string, non-empty) - per schema
    require_string_field "$payload" "starting" "project" || return 1

    # Required: model (string, non-empty) - per schema
    require_string_field "$payload" "starting" "model" || return 1

    # Required: gitBranch (string, non-empty) - per schema
    require_string_field "$payload" "starting" "gitBranch" || return 1

    # Required: gitStatus (must be "clean" or "dirty") - per schema
    if ! echo "$payload" | jq -e 'has("gitStatus")' >/dev/null 2>&1; then
        error_missing_field "starting" "gitStatus"
        show_required_fields "starting"
        return 1
    fi

    local git_status
    git_status=$(echo "$payload" | jq -r '.gitStatus // ""')
    case "$git_status" in
        clean|dirty) ;;
        "")
            echo "Error: starting.gitStatus cannot be empty" >&2
            echo "  Expected: \"gitStatus\": \"clean\" (one of: clean, dirty)" >&2
            show_required_fields "starting"
            return 1
            ;;
        *)
            echo "Error: starting.gitStatus must be one of: clean, dirty" >&2
            echo "  Got: \"$git_status\"" >&2
            echo "  Expected: \"gitStatus\": \"clean\" or \"gitStatus\": \"dirty\"" >&2
            return 1
            ;;
    esac

    # Optional: taskId (if present, must be non-empty string)
    if echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        local task_id
        task_id=$(echo "$payload" | jq -r '.taskId // ""')
        if [[ -z "$task_id" ]]; then
            echo "Error: starting.taskId cannot be empty when provided" >&2
            return 1
        fi
    fi

    # Optional: taskTitle (if present, must be non-empty string)
    if echo "$payload" | jq -e 'has("taskTitle")' >/dev/null 2>&1; then
        local task_title
        task_title=$(echo "$payload" | jq -r '.taskTitle // ""')
        if [[ -z "$task_title" ]]; then
            echo "Error: starting.taskTitle cannot be empty when provided" >&2
            return 1
        fi
    fi

    # Optional: tools (if present, must be array)
    if echo "$payload" | jq -e 'has("tools")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.tools | type == "array"' >/dev/null 2>&1; then
            echo "Error: starting.tools must be an array" >&2
            echo "  Expected: \"tools\": [\"Bash\", \"Read\", \"Write\", ...]" >&2
            return 1
        fi
    fi

    # Optional: uncommittedFiles (if present, must be array)
    if echo "$payload" | jq -e 'has("uncommittedFiles")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.uncommittedFiles | type == "array"' >/dev/null 2>&1; then
            echo "Error: starting.uncommittedFiles must be an array" >&2
            echo "  Expected: \"uncommittedFiles\": [\"path/to/file.ts\", ...]" >&2
            return 1
        fi
    fi

    return 0
}

validate_compacting() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: compacting signal must be a JSON object" >&2
        show_required_fields "compacting"
        return 1
    fi

    # Required: reason (string, non-empty)
    require_string_field "$payload" "compacting" "reason" || return 1

    # Required: contextSizeBefore (integer, non-negative)
    require_integer_field "$payload" "compacting" "contextSizeBefore" 0 || return 1

    # Validate preserving is array if present
    if echo "$payload" | jq -e 'has("preserving")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.preserving | type == "array"' >/dev/null 2>&1; then
            echo "Error: compacting.preserving must be an array" >&2
            return 1
        fi
    fi

    return 0
}

validate_question() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: question signal must be a JSON object" >&2
        show_required_fields "question"
        return 1
    fi

    # Required: question (string, non-empty)
    require_string_field "$payload" "question" "question" || return 1

    # Required: questionType (must be valid enum value)
    if ! echo "$payload" | jq -e 'has("questionType")' >/dev/null 2>&1; then
        error_missing_field "question" "questionType"
        show_required_fields "question"
        return 1
    fi

    local question_type
    question_type=$(echo "$payload" | jq -r '.questionType // ""')
    case "$question_type" in
        choice|confirm|input) ;;
        "")
            echo "Error: question.questionType cannot be empty" >&2
            echo "  Expected: \"questionType\": \"choice\" (one of: choice, confirm, input)" >&2
            show_required_fields "question"
            return 1
            ;;
        *)
            echo "Error: question.questionType must be one of: choice, confirm, input" >&2
            echo "  Got: \"$question_type\"" >&2
            return 1
            ;;
    esac

    # Validate options array if present
    if echo "$payload" | jq -e 'has("options")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.options | type == "array"' >/dev/null 2>&1; then
            echo "Error: question.options must be an array" >&2
            return 1
        fi

        # Validate each option has label and value
        local count
        count=$(echo "$payload" | jq '.options | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local option
            option=$(echo "$payload" | jq ".options[$i]")

            # Required: label
            if ! echo "$option" | jq -e 'has("label")' >/dev/null 2>&1; then
                echo "Error: question.options[$i] missing required field 'label'" >&2
                return 1
            fi
            local label
            label=$(echo "$option" | jq -r '.label // ""')
            if [[ -z "$label" ]]; then
                echo "Error: question.options[$i].label cannot be empty" >&2
                return 1
            fi

            # Required: value
            if ! echo "$option" | jq -e 'has("value")' >/dev/null 2>&1; then
                echo "Error: question.options[$i] missing required field 'value'" >&2
                return 1
            fi
            local value
            value=$(echo "$option" | jq -r '.value // ""')
            if [[ -z "$value" ]]; then
                echo "Error: question.options[$i].value cannot be empty" >&2
                return 1
            fi

            # description is optional, but if present must be a string
            if echo "$option" | jq -e 'has("description")' >/dev/null 2>&1; then
                if ! echo "$option" | jq -e '.description | type == "string"' >/dev/null 2>&1; then
                    echo "Error: question.options[$i].description must be a string" >&2
                    return 1
                fi
            fi

            # Check for unknown fields in option
            local unknown
            unknown=$(echo "$option" | jq -r 'keys - ["label","value","description"] | .[0] // ""')
            if [[ -n "$unknown" ]]; then
                echo "Error: question.options[$i] has unknown field '$unknown'" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate timeout if present (must be positive integer)
    local timeout
    timeout=$(echo "$payload" | jq '.timeout // null')
    if [[ "$timeout" != "null" ]]; then
        if ! echo "$timeout" | grep -qE '^[1-9][0-9]*$'; then
            echo "Error: question.timeout must be a positive integer" >&2
            return 1
        fi
    fi

    # Check for unknown fields in question signal
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["question","questionType","options","timeout"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: question signal has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

validate_reply() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: reply signal must be a JSON object" >&2
        show_required_fields "reply"
        return 1
    fi

    # Required: taskId (string, non-empty)
    require_string_field "$payload" "reply" "taskId" || return 1

    # Required: message (string, non-empty)
    require_string_field "$payload" "reply" "message" || return 1

    # Required: replyType (must be valid enum value)
    if ! echo "$payload" | jq -e 'has("replyType")' >/dev/null 2>&1; then
        error_missing_field "reply" "replyType"
        show_required_fields "reply"
        return 1
    fi

    local reply_type
    reply_type=$(echo "$payload" | jq -r '.replyType // ""')
    case "$reply_type" in
        ack|progress|question|completion) ;;
        "")
            echo "Error: reply.replyType cannot be empty" >&2
            echo "  Expected: \"replyType\": \"ack\" (one of: ack, progress, question, completion)" >&2
            show_required_fields "reply"
            return 1
            ;;
        *)
            echo "Error: reply.replyType must be one of: ack, progress, question, completion" >&2
            echo "  Got: \"$reply_type\"" >&2
            return 1
            ;;
    esac

    return 0
}

# =============================================================================
# Data Signal Validators (existing)
# =============================================================================

validate_complete() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: complete signal must be a JSON object" >&2
        return 1
    fi

    # Validate taskId if present (should be string)
    if echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.taskId | type == "string"' >/dev/null 2>&1; then
            echo "Error: complete.taskId must be a string" >&2
            return 1
        fi
    fi

    # Validate agentName if present (should be string)
    if echo "$payload" | jq -e 'has("agentName")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.agentName | type == "string"' >/dev/null 2>&1; then
            echo "Error: complete.agentName must be a string" >&2
            return 1
        fi
    fi

    # Validate summary if present (array of strings)
    if echo "$payload" | jq -e 'has("summary")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.summary | type == "array"' >/dev/null 2>&1; then
            echo "Error: complete.summary must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.summary | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: complete.summary must contain only strings" >&2
            return 1
        fi
    fi

    # Validate quality if present
    if echo "$payload" | jq -e 'has("quality")' >/dev/null 2>&1; then
        local quality
        quality=$(echo "$payload" | jq '.quality')
        if ! echo "$quality" | jq -e 'type == "object"' >/dev/null 2>&1; then
            echo "Error: complete.quality must be an object" >&2
            return 1
        fi
        validate_quality_signals "$quality" "complete." || return 1
    fi

    # Validate humanActions if present (reuse action validation)
    if echo "$payload" | jq -e 'has("humanActions")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.humanActions | type == "array"' >/dev/null 2>&1; then
            echo "Error: complete.humanActions must be an array" >&2
            return 1
        fi
        local count
        count=$(echo "$payload" | jq '.humanActions | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local action
            action=$(echo "$payload" | jq ".humanActions[$i]")

            # Validate each action
            if ! echo "$action" | jq -e 'has("title")' >/dev/null 2>&1; then
                echo "Error: complete.humanActions[$i] missing required field 'title'" >&2
                return 1
            fi

            local title
            title=$(echo "$action" | jq -r '.title // ""')
            if [[ -z "$title" ]]; then
                echo "Error: complete.humanActions[$i].title cannot be empty" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate suggestedTasks if present (reuse task validation)
    if echo "$payload" | jq -e 'has("suggestedTasks")' >/dev/null 2>&1; then
        local tasks
        tasks=$(echo "$payload" | jq '.suggestedTasks')
        if ! echo "$tasks" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "Error: complete.suggestedTasks must be an array" >&2
            return 1
        fi
        # Validate each task (but with complete. prefix in errors)
        local count
        count=$(echo "$tasks" | jq 'length')
        local i=0
        while [[ $i -lt $count ]]; do
            local task
            task=$(echo "$tasks" | jq ".[$i]")

            if ! echo "$task" | jq -e 'has("title")' >/dev/null 2>&1; then
                echo "Error: complete.suggestedTasks[$i] missing required field 'title'" >&2
                return 1
            fi

            local title
            title=$(echo "$task" | jq -r '.title // ""')
            if [[ -z "$title" ]]; then
                echo "Error: complete.suggestedTasks[$i].title cannot be empty" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate crossAgentIntel if present
    if echo "$payload" | jq -e 'has("crossAgentIntel")' >/dev/null 2>&1; then
        local intel
        intel=$(echo "$payload" | jq '.crossAgentIntel')
        if ! echo "$intel" | jq -e 'type == "object"' >/dev/null 2>&1; then
            echo "Error: complete.crossAgentIntel must be an object" >&2
            return 1
        fi
        validate_cross_agent_intel "$intel" "complete." || return 1
    fi

    # Validate completionMode if present
    local completion_mode
    completion_mode=$(echo "$payload" | jq -r '.completionMode // ""')
    if [[ -n "$completion_mode" ]]; then
        case "$completion_mode" in
            review_required|auto_proceed) ;;
            *)
                echo "Error: complete.completionMode must be one of: review_required, auto_proceed" >&2
                return 1
                ;;
        esac
    fi

    # Validate nextTaskId if present (should be string)
    if echo "$payload" | jq -e 'has("nextTaskId")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.nextTaskId | type == "string"' >/dev/null 2>&1; then
            echo "Error: complete.nextTaskId must be a string" >&2
            return 1
        fi
    fi

    # Validate nextTaskTitle if present (should be string)
    if echo "$payload" | jq -e 'has("nextTaskTitle")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.nextTaskTitle | type == "string"' >/dev/null 2>&1; then
            echo "Error: complete.nextTaskTitle must be a string" >&2
            return 1
        fi
    fi

    # Validate suggestedRename if present and not null (should be string)
    if echo "$payload" | jq -e 'has("suggestedRename") and .suggestedRename != null' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.suggestedRename | type == "string"' >/dev/null 2>&1; then
            echo "Error: complete.suggestedRename must be a string" >&2
            return 1
        fi
    fi

    # Validate suggestedLabels if present and not null (array of strings)
    if echo "$payload" | jq -e 'has("suggestedLabels") and .suggestedLabels != null' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.suggestedLabels | type == "array"' >/dev/null 2>&1; then
            echo "Error: complete.suggestedLabels must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.suggestedLabels | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: complete.suggestedLabels must contain only strings" >&2
            return 1
        fi
    fi

    # Validate riskLevel if present
    local risk_level
    risk_level=$(echo "$payload" | jq -r '.riskLevel // ""')
    if [[ -n "$risk_level" ]]; then
        case "$risk_level" in
            low|medium|high) ;;
            *)
                echo "Error: complete.riskLevel must be one of: low, medium, high" >&2
                return 1
                ;;
        esac
    fi

    # Validate breakingChanges if present and not null (array of strings)
    if echo "$payload" | jq -e 'has("breakingChanges") and .breakingChanges != null' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.breakingChanges | type == "array"' >/dev/null 2>&1; then
            echo "Error: complete.breakingChanges must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.breakingChanges | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: complete.breakingChanges must contain only strings" >&2
            return 1
        fi
    fi

    # Validate documentationNeeds if present and not null (array of strings)
    if echo "$payload" | jq -e 'has("documentationNeeds") and .documentationNeeds != null' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.documentationNeeds | type == "array"' >/dev/null 2>&1; then
            echo "Error: complete.documentationNeeds must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.documentationNeeds | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: complete.documentationNeeds must contain only strings" >&2
            return 1
        fi
    fi

    # Check for unknown fields
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["taskId","agentName","completionMode","nextTaskId","nextTaskTitle","summary","quality","humanActions","suggestedTasks","crossAgentIntel","suggestedRename","suggestedLabels","riskLevel","breakingChanges","documentationNeeds"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: complete has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

# Run validation based on signal type
case "$SIGNAL_TYPE" in
    complete)
        validate_complete "$PAYLOAD"
        ;;
    working)
        validate_working "$PAYLOAD"
        ;;
    review)
        validate_review "$PAYLOAD"
        ;;
    needs_input)
        validate_needs_input "$PAYLOAD"
        ;;
    idle)
        validate_idle "$PAYLOAD"
        ;;
    completing)
        validate_completing "$PAYLOAD"
        ;;
    starting)
        validate_starting "$PAYLOAD"
        ;;
    compacting)
        validate_compacting "$PAYLOAD"
        ;;
    question)
        validate_question "$PAYLOAD"
        ;;
    reply)
        validate_reply "$PAYLOAD"
        ;;
    *)
        echo "Error: Unknown signal type '$SIGNAL_TYPE'" >&2
        echo "Valid types: complete, working, review, needs_input, idle, completing, starting, compacting, question, reply" >&2
        exit 2
        ;;
esac

exit $?
