#!/usr/bin/env node
/**
 * jat-reply-router - Route agent replies back to originating channels.
 *
 * Looks up the task's origin metadata from the ingest database,
 * loads the appropriate adapter plugin, and calls adapter.send()
 * to deliver the message to the originating channel (Telegram, Slack, etc.).
 *
 * Usage:
 *   jat-reply-router --task-id jat-abc --message "Working on it" --type ack
 *   jat-reply-router --task-id jat-abc --message "Done!" --type completion
 *
 * Reply types: ack, progress, question, completion
 *
 * Requires:
 *   - Ingest database at ~/.local/share/jat/ingest.db
 *   - Origin metadata recorded for the task (stored during ingest)
 *   - Adapter plugin with send() support
 *   - Secret configured for the adapter (via jat-secret)
 */

import { getOriginByTaskId } from './lib/dedup.js';
import { discoverPlugins } from './lib/pluginLoader.js';
import { getSecret, getEnabledSources } from './lib/config.js';

const REPLY_TYPE_PREFIXES = {
  ack: '[ACK]',
  progress: '[PROGRESS]',
  question: '[QUESTION]',
  completion: '[DONE]'
};

function parseArgs(argv) {
  const args = { taskId: null, message: null, type: 'progress' };
  for (let i = 2; i < argv.length; i++) {
    switch (argv[i]) {
      case '--task-id':
        args.taskId = argv[++i];
        break;
      case '--message':
        args.message = argv[++i];
        break;
      case '--type':
        args.type = argv[++i];
        break;
      case '--help':
      case '-h':
        console.log('Usage: jat-reply-router --task-id ID --message TEXT [--type ack|progress|question|completion]');
        process.exit(0);
    }
  }
  return args;
}

async function main() {
  const args = parseArgs(process.argv);

  if (!args.taskId || !args.message) {
    console.error('Error: --task-id and --message are required');
    process.exit(1);
  }

  // 1. Look up origin metadata
  const origin = getOriginByTaskId(args.taskId);
  if (!origin) {
    console.error(`No origin metadata found for task ${args.taskId} (task may not have come from a channel)`);
    process.exit(0); // Not an error - task just wasn't from an ingest source
  }

  // 2. Find the source config to get the secretName
  const sources = getEnabledSources();
  const source = sources.find(s => s.id === origin.sourceId);
  const secretName = source?.secretName || origin.adapterType;

  // 3. Load the adapter plugin
  const plugins = await discoverPlugins();
  const plugin = plugins.get(origin.adapterType);
  if (!plugin) {
    console.error(`No adapter plugin found for type: ${origin.adapterType}`);
    process.exit(1);
  }

  const adapter = new plugin.AdapterClass();
  if (!adapter.supportsSend) {
    console.error(`Adapter ${origin.adapterType} does not support send()`);
    process.exit(1);
  }

  // 4. Build target and message
  const prefix = REPLY_TYPE_PREFIXES[args.type] || '';
  const target = {
    channelId: origin.channelId,
    threadId: origin.threadId,
    userId: origin.senderId,
    _secretName: secretName
  };
  const message = {
    text: `${prefix} ${args.message}`.trim()
  };

  // 5. Send
  try {
    await adapter.send(target, message, getSecret);
    console.log(`Reply sent to ${origin.adapterType} channel ${origin.channelId} (${args.type})`);
  } catch (err) {
    console.error(`Failed to send reply: ${err.message}`);
    process.exit(1);
  }
}

main();
