#!/bin/bash
# st - SQUAD task CLI (replaces bd)
# Pure bash + sqlite3. No Node startup cost.
set -euo pipefail

VERSION="0.1.0"
DB_NAME=".squad/tasks.db"

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

die() { echo "Error: $*" >&2; exit 1; }

# Find the project root (walk up looking for .squad/ or .git/)
find_project_root() {
  local dir="$PWD"
  while [[ "$dir" != "/" ]]; do
    [[ -d "$dir/.squad" ]] && echo "$dir" && return 0
    [[ -d "$dir/.git" ]] && echo "$dir" && return 0
    dir="$(dirname "$dir")"
  done
  echo "$PWD"
}

PROJECT_ROOT="$(find_project_root)"
DB="$PROJECT_ROOT/$DB_NAME"

# Get project prefix from directory name
project_prefix() {
  basename "$PROJECT_ROOT" | tr '[:upper:]' '[:lower:]' | tr -cd 'a-z0-9_-'
}

# Generate random task ID: prefix-xxxxx
gen_id() {
  local prefix
  prefix="$(project_prefix)"
  local rand
  rand=$(cat /dev/urandom | LC_ALL=C tr -dc 'a-z0-9' | head -c5)
  echo "${prefix}-${rand}"
}

# Current ISO timestamp
now_ts() {
  date -u +"%Y-%m-%dT%H:%M:%S.000Z"
}

# Touch sentinel for file watchers
touch_sentinel() {
  local sentinel="$PROJECT_ROOT/.squad/last-touched"
  date +%s%N > "$sentinel" 2>/dev/null || true
}

# Run a query, output JSON array (always returns [] for empty)
sql_json() {
  local out
  out="$(sqlite3 -json "$DB" "$1")"
  if [[ -z "$out" ]]; then
    echo "[]"
  else
    echo "$out"
  fi
}

# Run a query, no output expected (always enables foreign keys)
sql_exec() {
  sqlite3 "$DB" "PRAGMA foreign_keys=ON; $1"
}

# Ensure DB exists
require_db() {
  [[ -f "$DB" ]] || die "No .squad/ database found. Run 'st init' first."
}

# Escape single quotes for SQL
sql_escape() {
  echo "${1//\'/\'\'}"
}

# Validate integer input (prevents SQL injection via numeric fields)
require_integer() {
  [[ "$1" =~ ^-?[0-9]+$ ]] || die "$2 must be an integer, got: $1"
}

# Escape FTS5 query: add prefix matching for natural search behavior
escape_fts_query() {
  local query="$1"
  local result="" word
  for word in $query; do
    [[ -n "$word" ]] || continue
    if [[ "$word" =~ ^[a-zA-Z0-9_-]+$ ]]; then
      # Simple token: add * suffix for prefix matching (auth → auth*)
      result="$result ${word}*"
    else
      # Special chars: quote the token, no prefix
      word="${word//\"/\"\"}"
      result="$result \"$word\""
    fi
  done
  echo "${result# }"
}

# Ensure FTS5 index exists (auto-migration for existing databases)
ensure_fts() {
  local has_fts
  has_fts="$(sqlite3 "$DB" "SELECT name FROM sqlite_master WHERE type='table' AND name='tasks_fts';" 2>/dev/null || true)"
  [[ -z "$has_fts" ]] || return 0

  # Add labels_text column if missing
  local has_labels_text
  has_labels_text="$(sqlite3 "$DB" "PRAGMA table_info(tasks);" | grep -c 'labels_text' || true)"
  if [[ "$has_labels_text" == "0" ]]; then
    sqlite3 "$DB" "ALTER TABLE tasks ADD COLUMN labels_text TEXT DEFAULT '';"
  fi

  # Populate labels_text from labels table
  sqlite3 "$DB" "
    UPDATE tasks SET labels_text = COALESCE(
      (SELECT GROUP_CONCAT(label, ' ') FROM labels WHERE issue_id = tasks.id), ''
    );
  "

  # Create FTS5 table, backfill, and add triggers
  sqlite3 "$DB" "
    CREATE VIRTUAL TABLE tasks_fts USING fts5(
      title, description, labels_text,
      content=tasks, content_rowid=rowid,
      tokenize='porter unicode61'
    );

    INSERT INTO tasks_fts(rowid, title, description, labels_text)
    SELECT rowid, title, COALESCE(description, ''), COALESCE(labels_text, '')
    FROM tasks;

    CREATE TRIGGER IF NOT EXISTS tasks_fts_ai AFTER INSERT ON tasks BEGIN
      INSERT INTO tasks_fts(rowid, title, description, labels_text)
      VALUES (new.rowid, new.title, COALESCE(new.description, ''), COALESCE(new.labels_text, ''));
    END;

    CREATE TRIGGER IF NOT EXISTS tasks_fts_bd BEFORE DELETE ON tasks BEGIN
      INSERT INTO tasks_fts(tasks_fts, rowid, title, description, labels_text)
      VALUES('delete', old.rowid, old.title, COALESCE(old.description, ''), COALESCE(old.labels_text, ''));
    END;

    CREATE TRIGGER IF NOT EXISTS tasks_fts_bu BEFORE UPDATE OF title, description, labels_text ON tasks BEGIN
      INSERT INTO tasks_fts(tasks_fts, rowid, title, description, labels_text)
      VALUES('delete', old.rowid, old.title, COALESCE(old.description, ''), COALESCE(old.labels_text, ''));
    END;

    CREATE TRIGGER IF NOT EXISTS tasks_fts_au AFTER UPDATE OF title, description, labels_text ON tasks BEGIN
      INSERT INTO tasks_fts(rowid, title, description, labels_text)
      VALUES (new.rowid, new.title, COALESCE(new.description, ''), COALESCE(new.labels_text, ''));
    END;

    CREATE TRIGGER IF NOT EXISTS labels_ai_fts AFTER INSERT ON labels BEGIN
      UPDATE tasks SET labels_text = COALESCE(
        (SELECT GROUP_CONCAT(label, ' ') FROM labels WHERE issue_id = NEW.issue_id), ''
      ) WHERE id = NEW.issue_id;
    END;

    CREATE TRIGGER IF NOT EXISTS labels_ad_fts AFTER DELETE ON labels BEGIN
      UPDATE tasks SET labels_text = COALESCE(
        (SELECT GROUP_CONCAT(label, ' ') FROM labels WHERE issue_id = OLD.issue_id), ''
      ) WHERE id = OLD.issue_id;
    END;
  "
}

# ---------------------------------------------------------------------------
# Schema (embedded)
# ---------------------------------------------------------------------------

SCHEMA='
CREATE TABLE IF NOT EXISTS tasks (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT DEFAULT "",
    notes TEXT DEFAULT "",
    status TEXT NOT NULL DEFAULT "open",
    priority INTEGER NOT NULL DEFAULT 2,
    issue_type TEXT NOT NULL DEFAULT "task",
    assignee TEXT,
    reserved_files TEXT,
    parent_id TEXT REFERENCES tasks(id) ON DELETE SET NULL,
    command TEXT DEFAULT "/squad:start",
    agent_program TEXT,
    model TEXT,
    schedule_cron TEXT,
    next_run_at TEXT,
    due_date TEXT,
    labels_text TEXT DEFAULT "",
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    closed_at TEXT,
    close_reason TEXT DEFAULT ""
);
CREATE TABLE IF NOT EXISTS dependencies (
    issue_id TEXT NOT NULL,
    depends_on_id TEXT NOT NULL,
    type TEXT DEFAULT "blocks",
    PRIMARY KEY (issue_id, depends_on_id),
    FOREIGN KEY (issue_id) REFERENCES tasks(id) ON DELETE CASCADE,
    FOREIGN KEY (depends_on_id) REFERENCES tasks(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS labels (
    issue_id TEXT NOT NULL,
    label TEXT NOT NULL,
    PRIMARY KEY (issue_id, label),
    FOREIGN KEY (issue_id) REFERENCES tasks(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS comments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    issue_id TEXT NOT NULL,
    author TEXT NOT NULL,
    text TEXT NOT NULL,
    created_at TEXT NOT NULL,
    FOREIGN KEY (issue_id) REFERENCES tasks(id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_status_priority ON tasks(status, priority);
CREATE INDEX IF NOT EXISTS idx_deps_issue ON dependencies(issue_id);
CREATE INDEX IF NOT EXISTS idx_deps_depends ON dependencies(depends_on_id);
CREATE INDEX IF NOT EXISTS idx_labels_label ON labels(label);
CREATE INDEX IF NOT EXISTS idx_comments_issue ON comments(issue_id);
'

# ---------------------------------------------------------------------------
# Commands
# ---------------------------------------------------------------------------

cmd_init() {
  local quiet=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --quiet|-q) quiet=true; shift ;;
      *) shift ;;
    esac
  done

  local squad_dir="$PROJECT_ROOT/.squad"
  mkdir -p "$squad_dir"

  # .gitignore for .squad/
  if [[ ! -f "$squad_dir/.gitignore" ]]; then
    printf 'tasks.db\ntasks.db-wal\ntasks.db-shm\nlast-touched\n' > "$squad_dir/.gitignore"
  fi

  sqlite3 "$squad_dir/tasks.db" "PRAGMA journal_mode=WAL; PRAGMA foreign_keys=ON; $SCHEMA"

  # Migrate: add parent_id column if missing (for existing databases)
  local has_parent_id
  has_parent_id="$(sqlite3 "$squad_dir/tasks.db" "PRAGMA table_info(tasks);" | grep -c 'parent_id' || true)"
  if [[ "$has_parent_id" == "0" ]]; then
    sqlite3 "$squad_dir/tasks.db" "ALTER TABLE tasks ADD COLUMN parent_id TEXT REFERENCES tasks(id);"
    $quiet || echo "Migrated: added parent_id column"
  fi

  # Migrate: add scheduling columns if missing
  local has_command
  has_command="$(sqlite3 "$squad_dir/tasks.db" "PRAGMA table_info(tasks);" | grep -c '|command|' || true)"
  if [[ "$has_command" == "0" ]]; then
    sqlite3 "$squad_dir/tasks.db" "
      ALTER TABLE tasks ADD COLUMN command TEXT DEFAULT '/squad:start';
      ALTER TABLE tasks ADD COLUMN agent_program TEXT;
      ALTER TABLE tasks ADD COLUMN model TEXT;
      ALTER TABLE tasks ADD COLUMN schedule_cron TEXT;
      ALTER TABLE tasks ADD COLUMN next_run_at TEXT;
      ALTER TABLE tasks ADD COLUMN due_date TEXT;
      CREATE INDEX IF NOT EXISTS idx_tasks_next_run ON tasks(next_run_at);
      CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
    "
    $quiet || echo "Migrated: added scheduling columns (command, agent_program, model, schedule_cron, next_run_at, due_date)"
  fi

  # Migrate: add reserved_files column if missing
  local has_reserved_files
  has_reserved_files="$(sqlite3 "$squad_dir/tasks.db" "PRAGMA table_info(tasks);" | grep -c 'reserved_files' || true)"
  if [[ "$has_reserved_files" == "0" ]]; then
    sqlite3 "$squad_dir/tasks.db" "ALTER TABLE tasks ADD COLUMN reserved_files TEXT;"
    $quiet || echo "Migrated: added reserved_files column"
  fi

  # Migrate: add FTS5 full-text search index
  local saved_db="$DB"
  DB="$squad_dir/tasks.db"
  ensure_fts && { $quiet || echo "FTS5 search index ready"; }
  DB="$saved_db"

  touch_sentinel

  $quiet || echo "Initialized .squad/ in $PROJECT_ROOT"
}

cmd_create() {
  require_db
  local title="" description="" type="task" priority=2 labels="" deps="" assignee="" json_out=false explicit_id="" parent_id="" reserved_files=""
  local command="" agent_program="" model="" schedule_cron="" next_run_at="" due_date=""

  # First positional arg is title
  if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    title="$1"; shift
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --type)           type="$2"; shift 2 ;;
      --priority)       priority="$2"; shift 2 ;;
      --description)    description="$2"; shift 2 ;;
      --labels)         labels="$2"; shift 2 ;;
      --deps)           deps="$2"; shift 2 ;;
      --assignee)       assignee="$2"; shift 2 ;;
      --files)          reserved_files="$2"; shift 2 ;;
      --id)             explicit_id="$2"; shift 2 ;;
      --parent)         parent_id="$2"; shift 2 ;;
      --command)        command="$2"; shift 2 ;;
      --agent-program)  agent_program="$2"; shift 2 ;;
      --model)          model="$2"; shift 2 ;;
      --schedule-cron)  schedule_cron="$2"; shift 2 ;;
      --next-run-at)    next_run_at="$2"; shift 2 ;;
      --due-date)       due_date="$2"; shift 2 ;;
      --json)           json_out=true; shift ;;
      *)                [[ -z "$title" ]] && title="$1"; shift ;;
    esac
  done

  [[ -n "$title" ]] || die "Usage: st create \"title\" [--type X] [--priority N] [--description \"...\"] [--labels \"a,b\"] [--deps \"id1,id2\"] [--assignee \"X\"] [--files \"glob1,glob2\"] [--parent EPIC_ID] [--command CMD] [--agent-program X] [--model X] [--schedule-cron EXPR] [--next-run-at ISO] [--due-date ISO] [--json]"

  require_integer "$priority" "--priority"
  local id="${explicit_id:-$(gen_id)}"

  # If --parent specified, generate hierarchical child ID and validate parent
  if [[ -n "$parent_id" ]]; then
    # Verify parent exists
    local parent_exists
    parent_exists="$(sql_json "SELECT id FROM tasks WHERE id = '$(sql_escape "$parent_id")';")"
    [[ "$parent_exists" == "[]" || -z "$parent_exists" ]] && die "Parent task not found: $parent_id"

    # Find next child number: query max existing child suffix
    local max_child
    max_child="$(sqlite3 "$DB" "SELECT COALESCE(MAX(CAST(SUBSTR(id, LENGTH('$(sql_escape "$parent_id")') + 2) AS INTEGER)), 0) FROM tasks WHERE id LIKE '$(sql_escape "$parent_id").%' AND id NOT LIKE '$(sql_escape "$parent_id").%.%';")"
    local next_child=$(( max_child + 1 ))
    id="${parent_id}.${next_child}"
  fi
  local ts
  ts="$(now_ts)"
  local esc_title esc_desc esc_assignee
  esc_title="$(sql_escape "$title")"
  esc_desc="$(sql_escape "$description")"
  esc_assignee="$(sql_escape "$assignee")"

  local esc_parent_id
  esc_parent_id="$(sql_escape "$parent_id")"

  local esc_type
  esc_type="$(sql_escape "$type")"

  local esc_reserved_files
  esc_reserved_files="$(sql_escape "$reserved_files")"

  local esc_command esc_agent_program esc_model esc_cron esc_next_run esc_due_date
  esc_command="$(sql_escape "$command")"
  esc_agent_program="$(sql_escape "$agent_program")"
  esc_model="$(sql_escape "$model")"
  esc_cron="$(sql_escape "$schedule_cron")"
  esc_next_run="$(sql_escape "$next_run_at")"
  esc_due_date="$(sql_escape "$due_date")"

  sql_exec "
    INSERT INTO tasks (id, title, description, status, priority, issue_type, assignee, reserved_files, parent_id, command, agent_program, model, schedule_cron, next_run_at, due_date, created_at, updated_at)
    VALUES ('$id', '$esc_title', '$esc_desc', 'open', $priority, '$esc_type', $([ -n "$assignee" ] && echo "'$esc_assignee'" || echo "NULL"), $([ -n "$reserved_files" ] && echo "'$esc_reserved_files'" || echo "NULL"), $([ -n "$parent_id" ] && echo "'$esc_parent_id'" || echo "NULL"), $([ -n "$command" ] && echo "'$esc_command'" || echo "NULL"), $([ -n "$agent_program" ] && echo "'$esc_agent_program'" || echo "NULL"), $([ -n "$model" ] && echo "'$esc_model'" || echo "NULL"), $([ -n "$schedule_cron" ] && echo "'$esc_cron'" || echo "NULL"), $([ -n "$next_run_at" ] && echo "'$esc_next_run'" || echo "NULL"), $([ -n "$due_date" ] && echo "'$esc_due_date'" || echo "NULL"), '$ts', '$ts');"

  # Auto-wire epic→child dependency: parent depends on child (child is READY, parent is BLOCKED)
  if [[ -n "$parent_id" ]]; then
    sql_exec "INSERT OR IGNORE INTO dependencies (issue_id, depends_on_id, type) VALUES ('$(sql_escape "$parent_id")', '$id', 'blocks');"
  fi

  # Insert labels
  if [[ -n "$labels" ]]; then
    IFS=',' read -ra LABEL_ARR <<< "$labels"
    for lbl in "${LABEL_ARR[@]}"; do
      lbl="$(echo "$lbl" | xargs)"  # trim whitespace
      [[ -n "$lbl" ]] && sql_exec "INSERT INTO labels (issue_id, label) VALUES ('$id', '$(sql_escape "$lbl")');"
    done
  fi

  # Insert dependencies
  if [[ -n "$deps" ]]; then
    IFS=',' read -ra DEP_ARR <<< "$deps"
    for dep_id in "${DEP_ARR[@]}"; do
      dep_id="$(echo "$dep_id" | xargs)"
      [[ -n "$dep_id" ]] && sql_exec "INSERT OR IGNORE INTO dependencies (issue_id, depends_on_id, type) VALUES ('$id', '$(sql_escape "$dep_id")', 'blocks');"
    done
  fi

  touch_sentinel

  if $json_out; then
    cmd_show "$id" --json
  else
    echo "Created $id: $title"
  fi
}

cmd_update() {
  require_db
  local task_id="" json_out=false new_labels=""
  local -a sets=()

  # First positional arg is task_id
  if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    task_id="$1"; shift
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --status)         sets+=("status = '$(sql_escape "$2")'"); shift 2 ;;
      --priority)       require_integer "$2" "--priority"; sets+=("priority = $2"); shift 2 ;;
      --title)          sets+=("title = '$(sql_escape "$2")'"); shift 2 ;;
      --description)    sets+=("description = '$(sql_escape "$2")'"); shift 2 ;;
      --notes)          sets+=("notes = '$(sql_escape "$2")'"); shift 2 ;;
      --type)           sets+=("issue_type = '$(sql_escape "$2")'"); shift 2 ;;
      --assignee)       sets+=("assignee = '$(sql_escape "$2")'"); shift 2 ;;
      --files)          sets+=("reserved_files = '$(sql_escape "$2")'"); shift 2 ;;
      --labels)         new_labels="$2"; shift 2 ;;
      --command)        sets+=("command = '$(sql_escape "$2")'"); shift 2 ;;
      --agent-program)  sets+=("agent_program = '$(sql_escape "$2")'"); shift 2 ;;
      --model)          sets+=("model = '$(sql_escape "$2")'"); shift 2 ;;
      --schedule-cron)  sets+=("schedule_cron = '$(sql_escape "$2")'"); shift 2 ;;
      --next-run-at)    sets+=("next_run_at = '$(sql_escape "$2")'"); shift 2 ;;
      --due-date)       sets+=("due_date = '$(sql_escape "$2")'"); shift 2 ;;
      --json)           json_out=true; shift ;;
      *)                [[ -z "$task_id" ]] && task_id="$1"; shift ;;
    esac
  done

  [[ -n "$task_id" ]] || die "Usage: st update TASK_ID [--status X] [--priority N] [--assignee X] [--files \"globs\"] [--title X] [--command CMD] [--agent-program X] [--model X] [--schedule-cron EXPR] [--next-run-at ISO] [--due-date ISO] [--json]"

  # Check task exists
  local exists
  exists="$(sql_json "SELECT id FROM tasks WHERE id = '$(sql_escape "$task_id")';" 2>/dev/null)"
  [[ "$exists" == "[]" || -z "$exists" ]] && die "Task not found: $task_id"

  # Replace labels (deferred to after existence check)
  if [[ -n "$new_labels" ]]; then
    sql_exec "DELETE FROM labels WHERE issue_id = '$(sql_escape "$task_id")';"
    IFS=',' read -ra LABEL_ARR <<< "$new_labels"
    for lbl in "${LABEL_ARR[@]}"; do
      lbl="$(echo "$lbl" | xargs)"
      [[ -n "$lbl" ]] && sql_exec "INSERT INTO labels (issue_id, label) VALUES ('$(sql_escape "$task_id")', '$(sql_escape "$lbl")');"
    done
  fi

  if [[ ${#sets[@]} -gt 0 ]]; then
    local ts
    ts="$(now_ts)"
    # Handle closed_at for status transitions
    local status_set=""
    for s in "${sets[@]}"; do
      if [[ "$s" == *"status = 'closed'"* ]]; then
        status_set="closed"
      fi
    done

    local set_clause
    set_clause="$(IFS=','; echo "${sets[*]}")"
    set_clause="$set_clause, updated_at = '$ts'"

    if [[ "$status_set" == "closed" ]]; then
      set_clause="$set_clause, closed_at = '$ts'"
    fi

    sql_exec "UPDATE tasks SET $set_clause WHERE id = '$(sql_escape "$task_id")';"
  fi

  touch_sentinel

  if $json_out; then
    cmd_show "$task_id" --json
  else
    echo "Updated $task_id"
  fi
}

cmd_close() {
  require_db
  local task_id="" reason="" json_out=false

  if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    task_id="$1"; shift
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --reason) reason="$2"; shift 2 ;;
      --json)   json_out=true; shift ;;
      *)        [[ -z "$task_id" ]] && task_id="$1"; shift ;;
    esac
  done

  [[ -n "$task_id" ]] || die "Usage: st close TASK_ID [--reason \"...\"] [--json]"

  local exists
  exists="$(sql_json "SELECT id FROM tasks WHERE id = '$(sql_escape "$task_id")';" 2>/dev/null)"
  [[ "$exists" == "[]" || -z "$exists" ]] && die "Task not found: $task_id"

  local ts
  ts="$(now_ts)"
  sql_exec "UPDATE tasks SET status = 'closed', closed_at = '$ts', close_reason = '$(sql_escape "$reason")', reserved_files = NULL, updated_at = '$ts' WHERE id = '$(sql_escape "$task_id")';"

  touch_sentinel

  if $json_out; then
    cmd_show "$task_id" --json
  else
    echo "Closed $task_id"
  fi
}

# Build JSON for a task matching bd's output format
# Uses a single SQL query that aggregates labels and deps
_task_json() {
  local task_id="$1"
  local esc_id
  esc_id="$(sql_escape "$task_id")"

  sql_json "
    SELECT
      t.id, t.title, t.description, t.status, t.priority, t.issue_type,
      t.assignee, t.reserved_files, t.parent_id, t.command, t.agent_program, t.model,
      t.schedule_cron, t.next_run_at, t.due_date,
      t.created_at, t.updated_at, t.closed_at, t.close_reason,
      COALESCE(
        (SELECT json_group_array(l.label) FROM labels l WHERE l.issue_id = t.id),
        '[]'
      ) as labels,
      COALESCE(
        (SELECT json_group_array(json_object(
          'id', d.depends_on_id,
          'title', t2.title,
          'status', t2.status,
          'priority', t2.priority,
          'issue_type', t2.issue_type,
          'dependency_type', d.type
        ))
        FROM dependencies d
        LEFT JOIN tasks t2 ON d.depends_on_id = t2.id
        WHERE d.issue_id = t.id),
        '[]'
      ) as dependencies,
      COALESCE(
        (SELECT json_group_array(json_object(
          'id', d2.issue_id,
          'title', t3.title,
          'status', t3.status,
          'priority', t3.priority,
          'issue_type', t3.issue_type,
          'dependency_type', d2.type
        ))
        FROM dependencies d2
        LEFT JOIN tasks t3 ON d2.issue_id = t3.id
        WHERE d2.depends_on_id = t.id),
        '[]'
      ) as dependents
    FROM tasks t
    WHERE t.id = '$esc_id';
  "
}

cmd_show() {
  require_db
  local task_id="" json_out=false

  if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    task_id="$1"; shift
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) json_out=true; shift ;;
      *)      [[ -z "$task_id" ]] && task_id="$1"; shift ;;
    esac
  done

  [[ -n "$task_id" ]] || die "Usage: st show TASK_ID [--json]"

  local result
  result="$(_task_json "$task_id")"

  if [[ "$result" == "[]" || -z "$result" ]]; then
    die "Task not found: $task_id"
  fi

  if $json_out; then
    # Post-process: parse embedded JSON strings into actual arrays
    echo "$result" | _fix_json_arrays
  else
    # Human-readable output
    echo "$result" | _fix_json_arrays | _pretty_print_task
  fi
}

# Fix sqlite3's json_group_array returning strings instead of arrays
_fix_json_arrays() {
  python3 -c "
import sys, json
data = json.load(sys.stdin)
for item in data:
    for key in ('labels', 'dependencies', 'dependents'):
        val = item.get(key)
        if isinstance(val, str):
            try:
                item[key] = json.loads(val)
            except (json.JSONDecodeError, TypeError):
                pass
    # Remove null fields to match bd output
    for key in list(item.keys()):
        if item[key] is None and key not in ('assignee',):
            del item[key]
json.dump(data, sys.stdout, indent=2)
print()
"
}

# Pretty-print a task for human consumption
_pretty_print_task() {
  python3 -c "
import sys, json
data = json.load(sys.stdin)
for t in data:
    print(f\"[P{t['priority']}] {t['id']}: {t['title']}\")
    print(f\"  Status: {t['status']}  Type: {t['issue_type']}\")
    if t.get('assignee'):
        print(f\"  Assignee: {t['assignee']}\")
    if t.get('reserved_files'):
        print(f\"  Files: {t['reserved_files']}\")
    if t.get('description'):
        desc = t['description'][:200]
        print(f\"  Description: {desc}\")
    if t.get('command') and t['command'] != '/squad:start':
        print(f\"  Command: {t['command']}\")
    if t.get('agent_program'):
        model_str = f\" ({t['model']})\" if t.get('model') else ''
        print(f\"  Agent: {t['agent_program']}{model_str}\")
    elif t.get('model'):
        print(f\"  Model: {t['model']}\")
    if t.get('schedule_cron'):
        next_run = f\" (next: {t['next_run_at']})\" if t.get('next_run_at') else ''
        print(f\"  Schedule: {t['schedule_cron']}{next_run}\")
    elif t.get('next_run_at'):
        print(f\"  Next run: {t['next_run_at']}\")
    if t.get('due_date'):
        print(f\"  Due: {t['due_date']}\")
    labels = t.get('labels', [])
    if labels:
        print(f\"  Labels: {', '.join(labels)}\")
    deps = t.get('dependencies', [])
    if deps:
        print('  Dependencies:')
        for d in deps:
            print(f\"    -> {d['id']}: {d.get('title','')} [{d.get('status','')}]\")
    dependents = t.get('dependents', [])
    if dependents:
        print('  Dependents:')
        for d in dependents:
            print(f\"    <- {d['id']}: {d.get('title','')} [{d.get('status','')}]\")
"
}

cmd_list() {
  require_db
  local status="" type="" json_out=false limit=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --status) status="$2"; shift 2 ;;
      --type)   type="$2"; shift 2 ;;
      --limit)  limit="$2"; shift 2 ;;
      --json)   json_out=true; shift ;;
      *)        shift ;;
    esac
  done

  local where="1=1"
  [[ -n "$status" ]] && where="$where AND status = '$(sql_escape "$status")'"
  [[ -n "$type" ]]   && where="$where AND issue_type = '$(sql_escape "$type")'"
  local limit_clause=""
  if [[ -n "$limit" ]]; then
    require_integer "$limit" "--limit"
    limit_clause="LIMIT $limit"
  fi

  local result
  result="$(sql_json "
    SELECT
      t.id, t.title, t.description, t.status, t.priority, t.issue_type,
      t.assignee, t.reserved_files, t.command, t.agent_program, t.model,
      t.schedule_cron, t.next_run_at, t.due_date,
      t.created_at, t.updated_at, t.closed_at,
      COALESCE(
        (SELECT json_group_array(l.label) FROM labels l WHERE l.issue_id = t.id),
        '[]'
      ) as labels,
      (SELECT COUNT(*) FROM dependencies d WHERE d.issue_id = t.id) as dependency_count,
      (SELECT COUNT(*) FROM dependencies d WHERE d.depends_on_id = t.id) as dependent_count
    FROM tasks t
    WHERE $where
    ORDER BY t.priority ASC, t.created_at DESC
    $limit_clause;
  ")"

  if $json_out; then
    echo "$result" | _fix_json_arrays
  else
    if [[ "$result" == "[]" || -z "$result" ]]; then
      echo "No tasks found."
    else
      echo "$result" | _fix_json_arrays | python3 -c "
import sys, json
data = json.load(sys.stdin)
for t in data:
    labels = t.get('labels', [])
    lbl_str = (' [' + ', '.join(labels) + ']') if labels else ''
    assignee = (' @' + t['assignee']) if t.get('assignee') else ''
    print(f\"  [P{t['priority']}] {t['id']}: {t['title']}{lbl_str}{assignee} ({t['status']})\")
"
    fi
  fi
}

cmd_ready() {
  require_db
  local json_out=false limit=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json)  json_out=true; shift ;;
      --limit) limit="$2"; shift 2 ;;
      *)       shift ;;
    esac
  done

  local limit_clause=""
  if [[ -n "$limit" ]]; then
    require_integer "$limit" "--limit"
    limit_clause="LIMIT $limit"
  fi

  # Ready = open + no open/in_progress dependencies
  local result
  result="$(sql_json "
    SELECT
      t.id, t.title, t.description, t.status, t.priority, t.issue_type,
      t.assignee, t.reserved_files, t.command, t.agent_program, t.model,
      t.schedule_cron, t.next_run_at, t.due_date,
      t.created_at, t.updated_at,
      COALESCE(
        (SELECT json_group_array(l.label) FROM labels l WHERE l.issue_id = t.id),
        '[]'
      ) as labels,
      (SELECT COUNT(*) FROM dependencies d WHERE d.issue_id = t.id) as dependency_count,
      (SELECT COUNT(*) FROM dependencies d WHERE d.depends_on_id = t.id) as dependent_count
    FROM tasks t
    WHERE t.status = 'open'
      AND t.schedule_cron IS NULL
      AND NOT EXISTS (
        SELECT 1 FROM dependencies d
        JOIN tasks blocker ON d.depends_on_id = blocker.id
        WHERE d.issue_id = t.id AND blocker.status != 'closed'
      )
    ORDER BY t.priority ASC, t.created_at DESC
    $limit_clause;
  ")"

  if $json_out; then
    echo "$result" | _fix_json_arrays
  else
    if [[ "$result" == "[]" || -z "$result" ]]; then
      echo "No ready tasks."
    else
      echo "Ready tasks:"
      echo "$result" | _fix_json_arrays | python3 -c "
import sys, json
data = json.load(sys.stdin)
for t in data:
    labels = t.get('labels', [])
    lbl_str = (' [' + ', '.join(labels) + ']') if labels else ''
    print(f\"  [P{t['priority']}] {t['id']}: {t['title']}{lbl_str}\")
"
    fi
  fi
}

cmd_dep() {
  require_db
  local subcmd="${1:-}"; shift || true

  case "$subcmd" in
    add)    cmd_dep_add "$@" ;;
    remove) cmd_dep_remove "$@" ;;
    tree)   cmd_dep_tree "$@" ;;
    cycles) cmd_dep_cycles "$@" ;;
    *)      die "Usage: st dep {add|remove|tree|cycles} ..." ;;
  esac
}

cmd_dep_add() {
  local task_id="${1:-}" depends_on="${2:-}"
  [[ -n "$task_id" && -n "$depends_on" ]] || die "Usage: st dep add TASK_ID DEPENDS_ON_ID"

  [[ "$task_id" == "$depends_on" ]] && die "A task cannot depend on itself"

  # Verify both tasks exist
  local t1_exists t2_exists
  t1_exists="$(sql_json "SELECT id FROM tasks WHERE id = '$(sql_escape "$task_id")';")"
  [[ "$t1_exists" == "[]" || -z "$t1_exists" ]] && die "Task not found: $task_id"
  t2_exists="$(sql_json "SELECT id FROM tasks WHERE id = '$(sql_escape "$depends_on")';")"
  [[ "$t2_exists" == "[]" || -z "$t2_exists" ]] && die "Task not found: $depends_on"

  # Cycle detection
  local would_cycle
  would_cycle="$(sql_json "
    WITH RECURSIVE chain(id) AS (
      SELECT '$(sql_escape "$depends_on")'
      UNION ALL
      SELECT d.depends_on_id FROM dependencies d
      JOIN chain c ON d.issue_id = c.id
    )
    SELECT 1 as cycle FROM chain WHERE id = '$(sql_escape "$task_id")' LIMIT 1;
  ")"

  [[ "$would_cycle" != "[]" && -n "$would_cycle" ]] && die "Adding dependency would create a cycle: $task_id -> $depends_on"

  sql_exec "INSERT OR IGNORE INTO dependencies (issue_id, depends_on_id, type) VALUES ('$(sql_escape "$task_id")', '$(sql_escape "$depends_on")', 'blocks');"
  touch_sentinel
  echo "Added: $task_id depends on $depends_on"
}

cmd_dep_remove() {
  local task_id="${1:-}" depends_on="${2:-}"
  [[ -n "$task_id" && -n "$depends_on" ]] || die "Usage: st dep remove TASK_ID DEPENDS_ON_ID"

  sql_exec "DELETE FROM dependencies WHERE issue_id = '$(sql_escape "$task_id")' AND depends_on_id = '$(sql_escape "$depends_on")';"
  touch_sentinel
  echo "Removed: $task_id no longer depends on $depends_on"
}

cmd_dep_tree() {
  local task_id="" reverse=false json_out=false

  if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    task_id="$1"; shift
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --reverse) reverse=true; shift ;;
      --json)    json_out=true; shift ;;
      *)         [[ -z "$task_id" ]] && task_id="$1"; shift ;;
    esac
  done

  [[ -n "$task_id" ]] || die "Usage: st dep tree TASK_ID [--reverse] [--json]"

  local esc_id
  esc_id="$(sql_escape "$task_id")"
  local result

  if $reverse; then
    # What depends on this task
    result="$(sql_json "
      WITH RECURSIVE tree(id, depth) AS (
        SELECT d.issue_id, 1 FROM dependencies d WHERE d.depends_on_id = '$esc_id'
        UNION ALL
        SELECT d.issue_id, t.depth + 1 FROM dependencies d
        JOIN tree t ON d.depends_on_id = t.id
        WHERE t.depth < 20
      )
      SELECT DISTINCT tree.id, tree.depth, tsk.title, tsk.status, tsk.priority
      FROM tree
      LEFT JOIN tasks tsk ON tree.id = tsk.id
      ORDER BY tree.depth ASC, tsk.priority ASC;
    ")"
  else
    # What this task depends on
    result="$(sql_json "
      WITH RECURSIVE tree(id, depth) AS (
        SELECT d.depends_on_id, 1 FROM dependencies d WHERE d.issue_id = '$esc_id'
        UNION ALL
        SELECT d.depends_on_id, t.depth + 1 FROM dependencies d
        JOIN tree t ON d.issue_id = t.id
        WHERE t.depth < 20
      )
      SELECT DISTINCT tree.id, tree.depth, tsk.title, tsk.status, tsk.priority
      FROM tree
      LEFT JOIN tasks tsk ON tree.id = tsk.id
      ORDER BY tree.depth ASC, tsk.priority ASC;
    ")"
  fi

  if $json_out; then
    echo "$result"
  else
    if [[ "$result" == "[]" || -z "$result" ]]; then
      if $reverse; then
        echo "No tasks depend on $task_id"
      else
        echo "$task_id has no dependencies"
      fi
    else
      if $reverse; then
        echo "Tasks that depend on $task_id:"
      else
        echo "Dependencies of $task_id:"
      fi
      echo "$result" | python3 -c "
import sys, json
data = json.load(sys.stdin)
for d in data:
    indent = '  ' * d['depth']
    print(f\"{indent}-> {d['id']}: {d.get('title','')} [{d.get('status','')}]\")
"
    fi
  fi
}

cmd_dep_cycles() {
  local result
  result="$(sql_json "
    WITH RECURSIVE chain(start_id, id, depth) AS (
      SELECT issue_id, depends_on_id, 1 FROM dependencies
      UNION ALL
      SELECT c.start_id, d.depends_on_id, c.depth + 1
      FROM chain c
      JOIN dependencies d ON c.id = d.issue_id
      WHERE c.depth < 20
    )
    SELECT DISTINCT start_id as cycle_member FROM chain WHERE id = start_id;
  ")"

  if [[ "$result" == "[]" || -z "$result" ]]; then
    echo "No cycles detected."
  else
    echo "Cycles detected involving:"
    echo "$result" | python3 -c "
import sys, json
for item in json.load(sys.stdin):
    print(f\"  - {item['cycle_member']}\")
"
  fi
}

cmd_search() {
  require_db
  ensure_fts
  local query="" updated_after="" limit=50 json_out=false status="" type="" labels_filter=""

  if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    query="$1"; shift
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --updated-after) updated_after="$2"; shift 2 ;;
      --limit)         limit="$2"; shift 2 ;;
      --status)        status="$2"; shift 2 ;;
      --type)          type="$2"; shift 2 ;;
      --labels)        labels_filter="$2"; shift 2 ;;
      --json)          json_out=true; shift ;;
      *)               [[ -z "$query" ]] && query="$1"; shift ;;
    esac
  done

  [[ -n "$query" ]] || die "Usage: st search \"query\" [--status X] [--type X] [--labels \"a,b\"] [--updated-after DATE] [--limit N] [--json]"

  require_integer "$limit" "--limit"

  # Build SQL filter clauses
  local filters=""
  [[ -n "$status" ]] && filters="$filters AND t.status = '$(sql_escape "$status")'"
  [[ -n "$type" ]] && filters="$filters AND t.issue_type = '$(sql_escape "$type")'"
  [[ -n "$updated_after" ]] && filters="$filters AND t.updated_at >= '$(sql_escape "$updated_after")'"

  if [[ -n "$labels_filter" ]]; then
    local lbl
    IFS=',' read -ra FILTER_LABELS <<< "$labels_filter"
    for lbl in "${FILTER_LABELS[@]}"; do
      lbl="$(echo "$lbl" | xargs)"
      [[ -n "$lbl" ]] && filters="$filters AND EXISTS (SELECT 1 FROM labels l WHERE l.issue_id = t.id AND l.label = '$(sql_escape "$lbl")')"
    done
  fi

  local fts_query result fts_ok=true
  fts_query="$(escape_fts_query "$query")"

  # Try FTS5 MATCH query (BM25 ranked)
  result="$(sqlite3 -json "$DB" "
    SELECT
      t.id, t.title, t.description, t.status, t.priority, t.issue_type,
      t.assignee, t.created_at, t.updated_at, t.closed_at,
      ROUND(-tasks_fts.rank, 4) AS relevance,
      COALESCE(
        (SELECT json_group_array(l.label) FROM labels l WHERE l.issue_id = t.id),
        '[]'
      ) as labels
    FROM tasks_fts
    JOIN tasks t ON t.rowid = tasks_fts.rowid
    WHERE tasks_fts MATCH '$(sql_escape "$fts_query")'
      $filters
    ORDER BY tasks_fts.rank
    LIMIT $limit;
  " 2>/dev/null)" || fts_ok=false
  [[ -z "$result" ]] && result="[]"

  # Fallback: if FTS query had a syntax error, try quoting each word
  if ! $fts_ok; then
    local fallback_words fallback_query=""
    for fallback_words in $query; do
      [[ ${#fallback_words} -ge 2 ]] || continue
      fallback_words="${fallback_words//\"/\"\"}"
      fallback_query="$fallback_query \"$fallback_words\""
    done
    fallback_query="${fallback_query# }"

    if [[ -n "$fallback_query" ]]; then
      result="$(sqlite3 -json "$DB" "
        SELECT
          t.id, t.title, t.description, t.status, t.priority, t.issue_type,
          t.assignee, t.created_at, t.updated_at, t.closed_at,
          ROUND(-tasks_fts.rank, 4) AS relevance,
          COALESCE(
            (SELECT json_group_array(l.label) FROM labels l WHERE l.issue_id = t.id),
            '[]'
          ) as labels
        FROM tasks_fts
        JOIN tasks t ON t.rowid = tasks_fts.rowid
        WHERE tasks_fts MATCH '$(sql_escape "$fallback_query")'
          $filters
        ORDER BY tasks_fts.rank
        LIMIT $limit;
      " 2>/dev/null)" || true
      [[ -z "$result" ]] && result="[]"
    fi
  fi

  if $json_out; then
    echo "$result" | _fix_json_arrays
  else
    if [[ "$result" == "[]" || -z "$result" ]]; then
      echo "No tasks matching \"$query\"."
    else
      echo "Search results for \"$query\":"
      echo "$result" | _fix_json_arrays | python3 -c "
import sys, json
data = json.load(sys.stdin)
for t in data:
    rel = t.get('relevance', 0)
    rel_str = f' (score: {rel:.4f})' if rel else ''
    print(f\"  [P{t['priority']}] {t['id']}: {t['title']} ({t['status']}){rel_str}\")
"
    fi
  fi
}

cmd_delete() {
  require_db
  local task_id=""

  if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    task_id="$1"; shift
  fi

  [[ -n "$task_id" ]] || die "Usage: st delete TASK_ID"

  local exists
  exists="$(sql_json "SELECT id FROM tasks WHERE id = '$(sql_escape "$task_id")';" 2>/dev/null)"
  [[ "$exists" == "[]" || -z "$exists" ]] && die "Task not found: $task_id"

  # Clear parent_id references before delete (handles existing DBs without ON DELETE SET NULL)
  sql_exec "UPDATE tasks SET parent_id = NULL WHERE parent_id = '$(sql_escape "$task_id")'; DELETE FROM tasks WHERE id = '$(sql_escape "$task_id")';"
  touch_sentinel
  echo "Deleted $task_id"
}

cmd_help() {
  cat <<'HELP'
st - SQUAD task CLI

Usage: st <command> [options]

Commands:
  create  "title" [--type X] [--priority N] [--description "..."]
                   [--labels "a,b"] [--deps "id1,id2"] [--assignee "X"]
                   [--files "glob1,glob2"] [--parent EPIC_ID] [--json]
  update  TASK_ID  [--status X] [--priority N] [--assignee X] [--title X]
                   [--description "..."] [--notes "..."] [--labels "a,b"]
                   [--files "glob1,glob2"] [--json]
  close   TASK_ID  [--reason "..."] [--json]
  delete  TASK_ID
  show    TASK_ID  [--json]
  list    [--status X] [--type X] [--limit N] [--json]
  ready   [--json] [--limit N]
  search  "query"  [--status X] [--type X] [--labels "a,b"]
                   [--updated-after DATE] [--limit N] [--json]
  dep     add TASK_ID DEPENDS_ON_ID
  dep     remove TASK_ID DEPENDS_ON_ID
  dep     tree TASK_ID [--reverse] [--json]
  dep     cycles
  init    [--quiet]

Options:
  --version    Show version
  --help       Show this help

Status values: open, in_progress, blocked, closed
Task types: bug, feature, task, epic, chore
HELP
}

# ---------------------------------------------------------------------------
# Main dispatch
# ---------------------------------------------------------------------------

case "${1:-}" in
  create)    shift; cmd_create "$@" ;;
  update)    shift; cmd_update "$@" ;;
  close)     shift; cmd_close "$@" ;;
  delete)    shift; cmd_delete "$@" ;;
  show)      shift; cmd_show "$@" ;;
  list)      shift; cmd_list "$@" ;;
  ready)     shift; cmd_ready "$@" ;;
  search)    shift; cmd_search "$@" ;;
  dep)       shift; cmd_dep "$@" ;;
  init)      shift; cmd_init "$@" ;;
  --version) echo "st $VERSION" ;;
  --help|-h|help) cmd_help ;;
  "")        cmd_help ;;
  *)         die "Unknown command: $1. Run 'st --help' for usage." ;;
esac
