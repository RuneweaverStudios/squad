#!/usr/bin/env node
/**
 * squad-reply-router - Route agent replies back to originating channels.
 *
 * Looks up the task's origin metadata from the ingest database,
 * loads the appropriate adapter plugin, and calls adapter.send()
 * to deliver the message to the originating channel (Telegram, Slack, etc.).
 *
 * Usage:
 *   squad-reply-router --task-id squad-abc --message "Working on it" --type ack
 *   squad-reply-router --task-id squad-abc --message "Done!" --type completion
 *
 * Reply types: ack, progress, question, completion
 *
 * Requires:
 *   - Ingest database at ~/.local/share/squad/ingest.db
 *   - Origin metadata recorded for the task (stored during ingest)
 *   - Adapter plugin with send() support
 *   - Secret configured for the adapter (via squad-secret)
 */

import { readFileSync, writeFileSync } from 'node:fs';
import { getOriginByTaskId, registerThread } from './lib/dedup.js';
import { discoverPlugins } from './lib/pluginLoader.js';
import { getSecret, getEnabledSources } from './lib/config.js';

const REPLY_TYPE_PREFIXES = {
  ack: '[ACK]',
  answer: '',
  progress: '[PROGRESS]',
  question: '[QUESTION]',
  completion: '[DONE]'
};

// Simple dedup: track recent sends to prevent double-replies within a short window.
// Prevents agents from accidentally sending the same message twice (e.g. sending
// both an "answer" and "question" reply with identical content).
const DEDUP_FILE = '/tmp/squad-reply-router-dedup.json';
const DEDUP_WINDOW_MS = 10000; // 10 seconds

function isDuplicateReply(taskId, message) {
  try {
    let recent = {};
    try { recent = JSON.parse(readFileSync(DEDUP_FILE, 'utf-8')); } catch { /* fresh */ }
    const now = Date.now();
    // Clean old entries
    for (const key of Object.keys(recent)) {
      if (now - recent[key] > DEDUP_WINDOW_MS) delete recent[key];
    }
    const key = `${taskId}:${message.slice(0, 200)}`;
    if (recent[key]) {
      return true;
    }
    recent[key] = now;
    writeFileSync(DEDUP_FILE, JSON.stringify(recent), 'utf-8');
    return false;
  } catch { return false; }
}

function parseArgs(argv) {
  const args = { taskId: null, message: null, type: 'progress' };
  for (let i = 2; i < argv.length; i++) {
    switch (argv[i]) {
      case '--task-id':
        args.taskId = argv[++i];
        break;
      case '--message':
        args.message = argv[++i];
        break;
      case '--type':
        args.type = argv[++i];
        break;
      case '--help':
      case '-h':
        console.log('Usage: squad-reply-router --task-id ID --message TEXT [--type ack|progress|question|completion]');
        process.exit(0);
    }
  }
  return args;
}

async function main() {
  const args = parseArgs(process.argv);

  if (!args.taskId || !args.message) {
    console.error('Error: --task-id and --message are required');
    process.exit(1);
  }

  // 1. Look up origin metadata
  const origin = getOriginByTaskId(args.taskId);
  if (!origin) {
    console.error(`No origin metadata found for task ${args.taskId} (task may not have come from a channel)`);
    process.exit(0); // Not an error - task just wasn't from an ingest source
  }

  // 2. Find the source config to get the secretName
  const sources = getEnabledSources();
  const source = sources.find(s => s.id === origin.sourceId);
  const secretName = source?.secretName || origin.adapterType;

  // 3. Load the adapter plugin
  const plugins = await discoverPlugins();
  const plugin = plugins.get(origin.adapterType);
  if (!plugin) {
    console.error(`No adapter plugin found for type: ${origin.adapterType}`);
    process.exit(1);
  }

  const adapter = new plugin.AdapterClass();
  if (!adapter.supportsSend) {
    console.error(`Adapter ${origin.adapterType} does not support send()`);
    process.exit(1);
  }

  // 4. Dedup check â€” prevent same message sent twice in quick succession
  if (isDuplicateReply(args.taskId, args.message)) {
    console.log(`Duplicate reply suppressed for ${args.taskId} (same message within ${DEDUP_WINDOW_MS / 1000}s)`);
    process.exit(0);
  }

  // 5. Build target and message
  const prefix = REPLY_TYPE_PREFIXES[args.type] ?? '';
  const target = {
    channelId: origin.channelId,
    threadId: origin.threadId,
    userId: origin.senderId,
    _secretName: secretName
  };
  const message = {
    text: `${prefix} ${args.message}`.trim()
  };

  // 6. Send and register bot reply for thread tracking
  try {
    const result = await adapter.send(target, message, getSecret);
    console.log(`Reply sent to ${origin.adapterType} channel ${origin.channelId} (${args.type})`);

    // Register the bot's sent message ID so user replies to it route back to this task
    if (result?.messageId) {
      registerThread(origin.sourceId, result.messageId, new Date().toISOString(), args.taskId);
      console.log(`Registered bot reply ${result.messageId} for thread tracking`);
    }
  } catch (err) {
    console.error(`Failed to send reply: ${err.message}`);
    process.exit(1);
  }
}

main();
